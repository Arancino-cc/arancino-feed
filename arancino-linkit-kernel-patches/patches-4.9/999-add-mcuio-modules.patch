Index: linux-4.9.87/drivers/mcuio/Kconfig
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/Kconfig
@@ -0,0 +1,32 @@
+menuconfig MCUIO
+	tristate "mcuio drivers"
+	select REGMAP_MCUIO
+	help
+	  MCUIO is a protocol and a set of drivers which let a Linux MPU
+	  (MPU = MicroProcessor Unit) control an MCU's peripherals
+	  (MCU = Micro Controller Unit, some kind of tiny microcontroller
+	  running a tiny OS or no OS at all).
+
+if MCUIO
+
+config MCUIO_LDISC_HC
+	tristate "mcuio line discipline host controller"
+	default y
+	help
+	  This adds a line-discipline based MCUIO host controller, which is
+	  the only host controller at present. Say Y if in doubt.
+
+config MCUIO_SHIELDS_MANUAL_PROBE
+	tristate "mcuio shields manual probe"
+	default y
+	help
+	  Since autoprobe of mcuio shields is not implemented yet, this option
+	  makes it possible to manually register shields (experimental).
+
+config MCUIO_IRQ_TEST
+        tristate "mcuio irq test function driver"
+	default n
+	help
+	  Adds a driver for the irq test mcuio function
+
+endif # MCUIO
Index: linux-4.9.87/drivers/mcuio/bus.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/bus.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include "mcuio-internal.h"
+
+static inline int mcuio_device_is_host_controller(struct mcuio_device *mdev)
+{
+	return mdev->id.class == MCUIO_CLASS_HOST_CONTROLLER ||
+	    mdev->id.class == MCUIO_CLASS_SOFT_HOST_CONTROLLER;
+}
+
+static struct bus_attribute def_bus_attrs[] = {
+	__ATTR_NULL,
+};
+
+static void mcuio_dev_default_release(struct device *dev)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	kfree(mdev);
+}
+
+/*
+ * mcuio_match_device
+ * @drv driver to match
+ * @dev device to match
+ *
+ */
+static int mcuio_match_device(struct device *dev, struct device_driver *drv)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	struct mcuio_driver *mdrv = to_mcuio_drv(drv);
+	const struct mcuio_device_id *id;
+	pr_debug("%s:%d\n", __func__, __LINE__);
+	for (id = mdrv->id_table;
+	     !(id->device == MCUIO_NO_DEVICE &&
+	       id->class == MCUIO_CLASS_UNDEFINED);
+	     id++) {
+		/* Device and vendor match first */
+		if (mdev->id.device == id->device &&
+		    mdev->id.vendor == id->vendor)
+			return 1;
+		/* Next try class match */
+		if (id->class != MCUIO_CLASS_UNDEFINED &&
+			mdev->id.class == (id->class & id->class_mask))
+			return 1;
+	}
+	return 0;
+}
+
+struct bus_type mcuio_bus_type = {
+	.name = "mcuio",
+	//.bus_attrs = def_bus_attrs,
+	.match = mcuio_match_device,
+};
+EXPORT_SYMBOL_GPL(mcuio_bus_type);
+
+static int mcuio_drv_probe(struct device *_dev)
+{
+	struct mcuio_driver *drv = to_mcuio_drv(_dev->driver);
+	struct mcuio_device *dev = to_mcuio_dev(_dev);
+
+	if (!drv->probe)
+		return -ENODEV;
+	return drv->probe(dev);
+}
+
+static int mcuio_drv_remove(struct device *_dev)
+{
+	struct mcuio_driver *drv = to_mcuio_drv(_dev->driver);
+	struct mcuio_device *dev = to_mcuio_dev(_dev);
+
+	if (drv->remove)
+		return drv->remove(dev);
+	_dev->driver = NULL;
+	return 0;
+}
+
+int mcuio_driver_register(struct mcuio_driver *drv, struct module *owner)
+{
+	drv->driver.owner = owner;
+	drv->driver.bus = &mcuio_bus_type;
+	if (drv->probe)
+		drv->driver.probe = mcuio_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = mcuio_drv_remove;
+	return driver_register(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(mcuio_driver_register);
+
+void mcuio_driver_unregister(struct mcuio_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(mcuio_driver_unregister);
+
+struct device mcuio_bus = {
+	.init_name	= "mcuio",
+};
+EXPORT_SYMBOL_GPL(mcuio_bus);
+
+static const struct attribute_group *default_dev_attr_groups[] = {
+	&mcuio_default_dev_attr_group,
+	NULL,
+};
+
+struct device_type mcuio_default_device_type = {
+	.name = "mcuiodev",
+	.groups = default_dev_attr_groups,
+	.release = mcuio_dev_default_release,
+};
+
+struct mcuio_device *mcuio_bus_find_hc(int bus)
+{
+	char _name[8];
+	struct device *dev;
+	sprintf(_name, "%d:0.0", bus);
+	dev = bus_find_device_by_name(&mcuio_bus_type, NULL, _name);
+	if (!dev)
+		return ERR_PTR(-ENODEV);
+
+	return container_of(dev, struct mcuio_device, dev);
+}
+EXPORT_SYMBOL_GPL(mcuio_bus_find_hc);
+
+int mcuio_device_register(struct mcuio_device *mdev,
+			  struct device_type *type,
+			  struct device *parent)
+{
+	int ret;
+	if (!mdev)
+		return -EINVAL;
+	mdev->dev.parent = parent ? parent : &mcuio_bus;
+	mdev->dev.bus = &mcuio_bus_type;
+	mdev->dev.type = type ? type : &mcuio_default_device_type;
+	dev_set_name(&mdev->dev, "%d:%d.%d", mdev->bus, mdev->device, mdev->fn);
+	ret = device_register(&mdev->dev);
+	if (!ret)
+		return ret;
+	put_device(&mdev->dev);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(mcuio_device_register);
+
+static int __mcuio_device_unregister(struct device *dev, void *dummy)
+{
+	device_unregister(dev);
+	return 0;
+}
+
+static void mcuio_unregister_children(struct mcuio_device *mdev)
+{
+	device_for_each_child(&mdev->dev, NULL, __mcuio_device_unregister);
+}
+
+void mcuio_device_unregister(struct mcuio_device *mdev)
+{
+	if (mcuio_device_is_host_controller(mdev))
+		mcuio_unregister_children(mdev);
+	__mcuio_device_unregister(&mdev->dev, NULL);
+}
+EXPORT_SYMBOL_GPL(mcuio_device_unregister);
Index: linux-4.9.87/drivers/mcuio/core.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/core.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2013 Dog Hunter SA
+ *
+ * Author Davide Ciminaghi
+ * GNU GPLv2
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/mcuio.h>
+#include <linux/completion.h>
+#include <linux/spinlock.h>
+#include <linux/bitops.h>
+#include <linux/i2c.h>
+#include <linux/mcuio_ids.h>
+#include "mcuio-internal.h"
+
+unsigned long int busnum;
+spinlock_t busnum_lock;
+
+int mcuio_get_bus(void)
+{
+	int out;
+	spin_lock(&busnum_lock);
+	if (busnum == 0xffffffff) {
+		out = -ENOMEM;
+		goto end;
+	}
+	out = find_last_bit(&busnum, sizeof(busnum));
+	if (out == sizeof(busnum))
+		out = 0;
+	set_bit(out, &busnum);
+end:
+	spin_unlock(&busnum_lock);
+	return out;
+}
+EXPORT_SYMBOL(mcuio_get_bus);
+
+void mcuio_put_bus(unsigned n)
+{
+	clear_bit(n, &busnum);
+}
+EXPORT_SYMBOL(mcuio_put_bus);
+
+static int match_i2c_mcuio(struct device *dev, void *dummy)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	return mdev->id.class == MCUIO_CLASS_I2C_CONTROLLER;
+}
+
+static int match_i2c_adap(struct device *dev, void *dummy)
+{
+	return dev->type == &i2c_adapter_type;
+}
+
+struct i2c_adapter *mcuio_get_i2c_adapter(struct mcuio_device *mdev)
+{
+	/* Look for mcuio i2c controller device */
+	struct device *hcdev = mdev->dev.parent;
+	struct device *mcuio_i2c_dev = device_find_child(hcdev,
+							 NULL,
+							 match_i2c_mcuio);
+	struct device *adap_dev;
+
+	if (!mcuio_i2c_dev) {
+		dev_err(&mdev->dev,
+			"Cannot find mcuio i2c adapter mcuio dev\n");
+		return NULL;
+	}
+	/* Found, now we need the corresponding adapter ... */
+	adap_dev = device_find_child(mcuio_i2c_dev, NULL, match_i2c_adap);
+	if (!adap_dev) {
+		dev_err(&mdev->dev, "Cannot find mcuio i2c adapter\n");
+		return NULL;
+	}
+	return to_i2c_adapter(adap_dev);
+}
+EXPORT_SYMBOL(mcuio_get_i2c_adapter);
+
+static int __init mcuio_init(void)
+{
+	int ret;
+	spin_lock_init(&busnum_lock);
+	ret = device_register(&mcuio_bus);
+	if (ret)
+		return ret;
+	/* Register mcuio bus */
+	return bus_register(&mcuio_bus_type);
+}
+
+static void __exit mcuio_exit(void)
+{
+	/* Remove mcuio bus */
+	device_unregister(&mcuio_bus);
+	bus_unregister(&mcuio_bus_type);
+	return;
+}
+
+postcore_initcall(mcuio_init);
+module_exit(mcuio_exit);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO subsys core module");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/mcuio/mcuio-hc-dev.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-hc-dev.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+
+/* mcuio host controller functions */
+
+#include <linux/mcuio.h>
+#include <linux/circ_buf.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/regmap.h>
+#include <linux/err.h>
+#include <linux/workqueue.h>
+#include <linux/circ_buf.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-hc.h>
+#include <linux/mcuio-soft-hc.h>
+#include "mcuio-internal.h"
+
+static struct mcuio_device_id default_hc_id = {
+	.device = MCUIO_DEVICE_GENERIC_HC,
+	.vendor = MCUIO_VENDOR_DOGHUNTER,
+	.class = MCUIO_CLASS_HOST_CONTROLLER,
+};
+
+void mcuio_hc_dev_default_release(struct device *dev)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	mcuio_put_bus(mdev->bus);
+	kfree(mdev);
+}
+EXPORT_SYMBOL(mcuio_hc_dev_default_release);
+
+static const struct attribute_group *hc_dev_attr_groups[] = {
+	&mcuio_default_dev_attr_group,
+	NULL,
+};
+
+static struct device_type hc_device_type = {
+	.name = "mcuio-host-controller",
+	.groups = hc_dev_attr_groups,
+};
+
+struct device *mcuio_add_hc_device(struct mcuio_device_id *id,
+				   struct mcuio_hc_platform_data *plat,
+				   void (*release)(struct device *))
+{
+	int b, ret = -ENOMEM;
+	struct mcuio_device *d = kzalloc(sizeof(*d), GFP_KERNEL);
+	if (!d)
+		return ERR_PTR(-ENOMEM);
+	b = mcuio_get_bus();
+	if (b < 0) {
+		ret = b;
+		goto err0;
+	}
+	d->bus = b;
+	d->device = 0;
+	d->fn = 0;
+	d->id = id ? *id : default_hc_id;
+	d->dev.platform_data = plat;
+	hc_device_type.release = release ? release :
+	    mcuio_hc_dev_default_release;
+	ret = mcuio_device_register(d, &hc_device_type, NULL);
+	if (ret < 0)
+		goto err1;
+	return &d->dev;
+
+err1:
+	mcuio_put_bus(b);
+err0:
+	kfree(d);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL(mcuio_add_hc_device);
+
+void mcuio_del_hc_device(struct device *dev)
+{
+	mcuio_device_unregister(to_mcuio_dev(dev));
+}
+EXPORT_SYMBOL(mcuio_del_hc_device);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO host controller code");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/mcuio/mcuio-hc-drv.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-hc-drv.c
@@ -0,0 +1,779 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+
+/* mcuio host controller driver */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/mutex.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-proto.h>
+#include <linux/mcuio-hc.h>
+
+#include "mcuio-internal.h"
+
+/* Max number of read descr timeout before skipping to next device */
+#define MAX_ENUM_RETRIES 2
+
+struct mcuio_request;
+
+typedef void (*___request_cb)(struct mcuio_request *);
+
+/* Host controller data */
+struct mcuio_hc_data {
+	unsigned bus;
+	struct mutex lock;
+	struct list_head request_queue;
+	struct list_head pending_requests;
+	atomic_t removing;
+
+	struct kthread_worker tx_kworker;
+	struct task_struct *tx_kworker_task;
+	struct kthread_work send_messages;
+
+	struct task_struct *rx_thread;
+	wait_queue_head_t rd_wq;
+
+	struct mcuio_device *mdev;
+	struct kthread_worker enum_kworker;
+	struct task_struct *enum_kworker_task;
+	struct kthread_work do_enum;
+
+	int *irqs[MCUIO_DEVS_PER_BUS];
+};
+
+typedef int (*mcuio_copy)(uint32_t *, const uint32_t *, int, int);
+
+int __mcuio_copyb(uint32_t *dst, const uint32_t *src, int fill, int ntoh)
+{
+	if (!fill) {
+		*(uint8_t *)dst = *(uint8_t *)src;
+		return sizeof(uint8_t);
+	}
+	memcpy(dst, src, sizeof(uint64_t));
+	return sizeof(uint64_t);
+}
+
+int __mcuio_copyw(uint32_t *__dst, const uint32_t *__src, int fill, int ntoh)
+{
+	uint16_t *dst = (uint16_t *)__dst;
+	uint16_t *src = (uint16_t *)__src;
+	int i, n = fill ? sizeof(uint64_t) / sizeof(uint16_t) : 1;
+	for (i = 0; i < n; i++)
+		*dst++ = ntoh ? mcuio_ntohs(*src++) : mcuio_htons(*src++);
+	return n * sizeof(uint16_t);
+}
+
+int __mcuio_copydw(uint32_t *dst, const uint32_t *src, int fill, int ntoh)
+{
+	*dst++ = mcuio_ntohl(*src++);
+	if (fill)
+		*dst++ = ntoh ? mcuio_ntohl(*src++) : mcuio_htonl(*src++);
+	return fill ? sizeof(uint64_t) : sizeof(uint32_t);
+}
+
+static const mcuio_copy __copy_table[] = {
+	[ mcuio_type_rdb ] = __mcuio_copyb,
+	[ mcuio_type_wrb ] = __mcuio_copyb,
+	[ mcuio_type_rdw ] = __mcuio_copyw,
+	[ mcuio_type_wrw ] = __mcuio_copyw,
+	[ mcuio_type_rddw ] = __mcuio_copydw,
+	[ mcuio_type_wrdw ] = __mcuio_copydw,
+	/* Unsupported */
+	[ mcuio_type_rdq ] = NULL,
+	[ mcuio_type_wrq ] = NULL,
+};
+
+static int __copy_data(uint32_t *addr, struct mcuio_packet *p, int ntoh)
+{
+	mcuio_copy cp = __copy_table[mcuio_packet_type(p) &
+				     mcuio_actual_type_mask];
+	uint32_t *__dst = ntoh ? addr : p->data;
+	uint32_t *__src = ntoh ? p->data : addr;
+	if (!cp)
+		return -ENOSYS;
+	return cp(__dst, __src, mcuio_packet_is_fill_data(p),
+		  ntoh ? mcuio_packet_is_read(p) : !mcuio_packet_is_read(p));
+}
+
+static void __free_request(struct mcuio_request *r)
+{
+	devm_kfree(&r->hc->dev, r);
+}
+
+static struct mcuio_request *mcuio_alloc_request(struct mcuio_device *mdev)
+{
+	struct mcuio_request *out = devm_kzalloc(&mdev->dev, sizeof(*out),
+						 GFP_KERNEL);
+	if (!out)
+		dev_err(&mdev->dev, "not enough memory for mcuio request\n");
+	out->release = __free_request;
+	return out;
+}
+
+
+static void __dequeue_request(struct mcuio_request *r)
+{
+	struct mcuio_hc_data *data;
+	data = dev_get_drvdata(&r->hc->dev);
+	mutex_lock(&data->lock);
+	list_del(&r->list);
+	mutex_unlock(&data->lock);
+}
+
+
+static void __request_to_packet(struct mcuio_request *r, struct mcuio_packet *p)
+{
+	mcuio_packet_set_addr(p, r->hc->bus, r->dev, r->func, r->offset,
+			      r->type, mcuio_request_is_fill(r));
+	if (mcuio_packet_is_read(p)) {
+		p->data[0] = p->data[1] = 0;
+		return;
+	}
+	/* Copy data to packet (host to network) */
+	__copy_data(r->data, p, 0);
+}
+
+static void __init_request(struct mcuio_request *r,
+			   struct mcuio_device *mdev,
+			   unsigned dev, unsigned func,
+			   unsigned type,
+			   int fill,
+			   unsigned offset,
+			   unsigned offset_mask)
+{
+	r->hc = mdev;
+	r->dev = dev;
+	r->func = func;
+	r->type = type;
+	r->offset = offset;
+	r->offset_mask = offset_mask;
+	r->status = -ETIMEDOUT;
+	mcuio_request_set_fill(r, fill);
+}
+
+struct mcuio_request *mcuio_make_request(struct mcuio_device *mdev,
+					 unsigned dev, unsigned func,
+					 unsigned type,
+					 int fill,
+					 unsigned offset,
+					 unsigned offset_mask)
+{
+	struct mcuio_request *out = mcuio_alloc_request(mdev);
+	if (!out)
+		return NULL;
+	__init_request(out, mdev, dev, func, type, fill, offset,
+		       offset_mask);
+	return out;
+}
+EXPORT_SYMBOL(mcuio_make_request);
+
+void mcuio_init_request(struct mcuio_request *r,
+			struct mcuio_device *mdev,
+			unsigned dev, unsigned func,
+			unsigned type,
+			int fill,
+			unsigned offset,
+			unsigned offset_mask)
+{
+	__init_request(r, mdev, dev, func, type, fill, offset, offset_mask);
+	r->release = NULL;
+}
+EXPORT_SYMBOL(mcuio_init_request);
+
+static void __request_timeout(struct work_struct *work)
+{
+	struct mcuio_request *r =
+		container_of(work, struct mcuio_request, to_work.work);
+	if (r->cb)
+		r->cb(r);
+	if (!mcuio_request_is_incoming(r))
+		__dequeue_request(r);
+}
+
+static int __write_message(struct regmap *map, const u32 *ptr, int count)
+{
+	int i, stat;
+
+	pr_debug("%s:", __func__);
+	dump_packet((struct mcuio_packet *)ptr);
+	for (i = 0; i < count; i++) {
+		stat = regmap_write(map,
+				    MCUIO_HC_OUTBUF + i * sizeof(u32), ptr[i]);
+		if (stat) {
+			pr_err("%s: error %d writing to hc\n", __func__, stat);
+			return stat;
+		}
+	}
+	return 0;
+}
+
+static int __do_request(struct mcuio_hc_data *data)
+{
+	struct mcuio_request *r;
+	struct mcuio_device *mdev;
+	struct regmap *map;
+	u32 buf[4];
+	struct mcuio_packet *p = (struct mcuio_packet *)buf;
+
+	mutex_lock(&data->lock);
+	if (list_empty(&data->request_queue)) {
+		mutex_unlock(&data->lock);
+		return 0;
+	}
+	r = list_entry(data->request_queue.next, struct mcuio_request, list);
+	__request_to_packet(r, p);
+	mdev = r->hc;
+	map = dev_get_regmap(&mdev->dev, NULL);
+	if (!map) {
+		mutex_unlock(&data->lock);
+		WARN_ON(1);
+		return -EIO;
+	}
+	list_move(&r->list, &data->pending_requests);
+	mutex_unlock(&data->lock);
+	/* Schedule timeout */
+	INIT_DELAYED_WORK(&r->to_work, __request_timeout);
+	/* FIXME: WHAT IS THE CORRECT DELAY ? */
+	schedule_delayed_work(&r->to_work, HZ/5);
+	if (__write_message(map, buf, 4) < 0) {
+		dev_err(&mdev->dev, "error writing to output fifo");
+		goto regmap_error;
+	}
+	return 1;
+
+regmap_error:
+	cancel_delayed_work_sync(&r->to_work);
+	return -EIO;
+}
+
+static irqreturn_t hc_irq_handler(int irq, void *__data)
+{
+	struct mcuio_device *mdev = __data;
+	struct regmap *map = dev_get_regmap(&mdev->dev, NULL);
+	struct mcuio_hc_data *data = dev_get_drvdata(&mdev->dev);
+	int ret;
+	u32 status;
+
+	if (!data) {
+		dev_err(&mdev->dev, "no drv data in irq handler\n");
+		return IRQ_NONE;
+	}
+	ret = regmap_read(map, MCUIO_IRQ_STAT, &status);
+	if (ret < 0)
+		return IRQ_NONE;
+	if (status & RX_RDY)
+		wake_up_interruptible(&data->rd_wq);
+	return IRQ_HANDLED;
+}
+
+static inline u32 __get_available(struct regmap *map)
+{
+	u32 out;
+	int stat = regmap_read(map, MCUIO_RX_CNT, &out);
+	if (stat < 0)
+		return 0;
+	return out;
+}
+
+static int __read_message(struct mcuio_hc_data *data,
+			  struct regmap *map, u32 *ptr, int count)
+{
+	int i, stat;
+
+	stat = wait_event_interruptible(data->rd_wq,
+					__get_available(map) >= count ||
+					kthread_should_stop());
+	/* FIXME: handle signals */
+	if (stat < 0) {
+		pr_debug("%s returns %d\n", __func__, stat);
+		return stat;
+	}
+
+	if (kthread_should_stop()) {
+		pr_debug("%s kthread_should_stop\n", __func__);
+		return -EINTR;
+	}
+
+	for (i = 0; i < count; i++, ptr++) {
+		stat = regmap_read(map, MCUIO_HC_INBUF + i * sizeof(u32), ptr);
+		if (stat < 0) {
+			pr_err("%s error %d reading from hc\n", __func__, stat);
+			return stat;
+		}
+	}
+	return 0;
+}
+
+static struct mcuio_request *__find_request(struct mcuio_device *hc,
+					    struct mcuio_packet *p)
+{
+	struct mcuio_request *r;
+	struct mcuio_hc_data *data = dev_get_drvdata(&hc->dev);
+
+	mutex_lock(&data->lock);
+	list_for_each_entry(r, &data->pending_requests, list) {
+		if ((mcuio_packet_type(p) & mcuio_actual_type_mask) ==
+		    (r->type & mcuio_actual_type_mask) &&
+		    mcuio_packet_bus(p) == hc->bus &&
+		    mcuio_packet_dev(p) == r->dev &&
+		    mcuio_packet_func(p) == r->func &&
+		    (mcuio_packet_offset(p) & r->offset_mask) ==
+		    (r->offset & r->offset_mask)) {
+			mutex_unlock(&data->lock);
+			return r;
+		}
+	}
+	mutex_unlock(&data->lock);
+	return NULL;
+}
+
+static int __receive_messages(void *__data)
+{
+	struct mcuio_device *hc = __data;
+	struct mcuio_hc_data *data = dev_get_drvdata(&hc->dev);
+	struct regmap *map;
+	if (!data) {
+		dev_err(&hc->dev, "no driver data in %s\n", __func__);
+		return -EINVAL;
+	}
+	map = dev_get_regmap(&hc->dev, NULL);
+	while (!kthread_should_stop()) {
+		u32 buf[4];
+		int stat;
+		struct mcuio_packet *p;
+		struct mcuio_request *r;
+		stat = __read_message(data, map, buf, 4);
+		if (stat < 0) {
+			schedule();
+			continue;
+		}
+		p = (struct mcuio_packet *)buf;
+		pr_debug("%s %d, packet received, type = %d\n",
+			 __func__, __LINE__, mcuio_packet_type(p));
+		dump_packet(p);
+		if (!mcuio_packet_is_reply(p)) {
+			if (mcuio_packet_is_read(p)) {
+				/*
+				  Packet is a read request, we do not handle
+				  read requests at the moment
+				*/
+				pr_debug("%s %d: unexpected read req\n",
+					 __func__, __LINE__);
+				continue;
+			}
+		}
+		r = __find_request(hc, p);
+		if (!r) {
+			dev_err(&hc->dev, "unexpected reply");
+			dump_packet(p);
+			continue;
+		}
+		r->status = mcuio_packet_is_error(p);
+		pr_debug("%s %d, r->status = %d\n", __func__, __LINE__,
+			 r->status);
+		cancel_delayed_work_sync(&r->to_work);
+		if (mcuio_packet_is_reply(p)) {
+			if (mcuio_packet_is_read(p))
+				__copy_data(r->data, p, 1);
+		} else {
+			r->offset = mcuio_packet_offset(p);
+			mcuio_request_set_fill(r, mcuio_packet_is_fill_data(p));
+			__copy_data(r->data, p, 1);
+		}
+		if (r->cb)
+			r->cb(r);
+		if (!mcuio_request_is_incoming(r))
+			__dequeue_request(r);
+	}
+	return 0;
+}
+
+static void __send_messages(struct kthread_work *work)
+{
+	struct mcuio_hc_data *data =
+		container_of(work, struct mcuio_hc_data, send_messages);
+	while (__do_request(data) > 0);
+}
+
+static void __enqueue_request(struct mcuio_device *mdev,
+			      struct mcuio_hc_data *data,
+			      struct mcuio_request *r,
+			      int outgoing)
+{
+	mcuio_request_set_incoming(r, !outgoing);
+	mutex_lock(&data->lock);
+	list_add_tail(&r->list, outgoing ? &data->request_queue :
+		      &data->pending_requests);
+	mutex_unlock(&data->lock);
+	if (outgoing)
+		kthread_queue_work(&data->tx_kworker, &data->send_messages);
+}
+
+static int mcuio_hc_enqueue_request(struct mcuio_request *r, int outgoing)
+{
+	struct mcuio_hc_data *data;
+	if (!r || !r->hc)
+		return -EINVAL;
+	data = dev_get_drvdata(&r->hc->dev);
+	if (!data)
+		return -EINVAL;
+	if (atomic_read(&data->removing))
+		return -ENODEV;
+	__enqueue_request(r->hc, data, r, outgoing);
+	return 0;
+}
+
+static void __request_cb(struct mcuio_request *r)
+{
+	struct completion *c = r->cb_data;
+	complete(c);
+}
+
+int mcuio_submit_request(struct mcuio_request *r)
+{
+	int ret;
+	DECLARE_COMPLETION_ONSTACK(request_complete);
+	r->cb = __request_cb;
+	r->cb_data = &request_complete;
+	r->status = -ETIMEDOUT;
+	ret = mcuio_hc_enqueue_request(r, 1);
+	if (ret)
+		return ret;
+	wait_for_completion(&request_complete);
+	return r->status;
+}
+EXPORT_SYMBOL(mcuio_submit_request);
+
+int mcuio_setup_cb(struct mcuio_request *r)
+{
+	return mcuio_hc_enqueue_request(r, 0);
+}
+EXPORT_SYMBOL(mcuio_setup_cb);
+
+int mcuio_cancel_cb(struct mcuio_request *r)
+{
+	struct mcuio_request *ptr, *tmp;
+	struct mcuio_hc_data *data;
+
+	if (!r->hc)
+		return -EINVAL;
+	data = dev_get_drvdata(&r->hc->dev);
+
+	if (!data)
+		return -EINVAL;
+
+	list_for_each_entry_safe(ptr, tmp, &data->pending_requests, list) {
+		if (ptr == r) {
+			mutex_lock(&data->lock);
+			list_del(&r->list);
+			mutex_unlock(&data->lock);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+EXPORT_SYMBOL(mcuio_cancel_cb);
+
+int mcuio_hc_set_irqs(struct mcuio_device *hc, unsigned dev, int __irqs[])
+{
+	struct mcuio_hc_data *data = dev_get_drvdata(&hc->dev);
+	int *irqs, size = sizeof(int) * MCUIO_FUNCS_PER_DEV;
+	if (!data) {
+		WARN_ON(1);
+		return -ENODEV;
+	}
+	if (dev > MCUIO_DEVS_PER_BUS) {
+		dev_warn(&hc->dev, "Invalid dev number %u\n", dev);
+		return -EINVAL;
+	}
+	irqs = devm_kzalloc(&hc->dev, size, GFP_KERNEL);
+	if (!irqs) {
+		dev_err(&hc->dev, "No memory for irqs for %u:%u\n", hc->bus,
+			dev);
+		return -ENOMEM;
+	}
+	memcpy(irqs, __irqs, size);
+	data->irqs[dev] = irqs;
+	return 0;
+}
+EXPORT_SYMBOL(mcuio_hc_set_irqs);
+
+static int __do_one_enum(struct mcuio_device *mdev, unsigned edev,
+			 unsigned efunc, struct mcuio_request **out)
+{
+	struct mcuio_request *r;
+	int ret;
+
+	r = mcuio_make_request(mdev, edev, efunc,
+			       mcuio_type_rddw, 1, 0, 0xffff);
+	if (!r) {
+		*out = NULL;
+		return -ENOMEM;
+	}
+	ret = mcuio_submit_request(r);
+	*out = r;
+	return ret;
+}
+
+static void __register_device(struct mcuio_request *r)
+{
+	struct mcuio_func_descriptor d;
+	struct mcuio_device *hc = r->hc;
+	struct mcuio_hc_data *data = dev_get_drvdata(&hc->dev);
+	struct mcuio_device *new;
+	new = kzalloc(sizeof(*new), GFP_KERNEL);
+	if (!new) {
+		dev_err(&r->hc->dev,
+			"error allocating device %u:%u.%u\n",
+			hc->bus, r->dev, r->func);
+		return;
+	}
+	memcpy(&d, r->data, sizeof(d));
+	new->id.device = mcuio_get_device(&d);
+	new->id.vendor = mcuio_get_vendor(&d);
+	new->id.class = d.rev_class;
+	new->id.class_mask = 0xffffffff;
+	new->bus = hc->bus;
+	new->device = r->dev;
+	new->fn = r->func;
+	if (data->irqs[r->dev])
+		new->irq = (data->irqs[r->dev])[r->func];
+	pr_debug("%s %d, device = 0x%04x, vendor = 0x%04x, "
+		 "class = 0x%04x\n", __func__, __LINE__, new->id.device,
+		 new->id.vendor, new->id.class);
+	if (mcuio_device_register(new, NULL, &hc->dev) < 0) {
+		dev_err(&r->hc->dev,
+			"error registering device %u:%u.%u\n",
+			hc->bus, r->dev, r->func);
+		kfree(new);
+	}
+}
+
+static int __next_enum(unsigned *edev, unsigned *efunc, int *retry)
+{
+	if ((*retry) > 0) {
+		/* Doing retries */
+		(*retry)--;
+		return 0;
+	}
+	if (!(*retry)) {
+		/* No reply and no more attempts left, skip to next device */
+		*retry = -1;
+		if ((*edev)++ >= MCUIO_DEVS_PER_BUS - 1)
+			return 1;
+		*efunc = 0;
+		return 0;
+	}
+	if ((*efunc)++ >= MCUIO_FUNCS_PER_DEV - 1) {
+		*efunc = 0;
+		if ((*edev)++ >= MCUIO_DEVS_PER_BUS - 1)
+			return 1;
+	}
+	return 0;
+}
+
+static void __do_enum(struct kthread_work *work)
+{
+	struct mcuio_hc_data *data =
+		container_of(work, struct mcuio_hc_data, do_enum);
+	struct mcuio_device *mdev = data->mdev;
+	struct mcuio_request *r;
+	unsigned edev, efunc;
+	int stop_enum, stat, retry = -1;
+
+	for (edev = 1, efunc = 0, stop_enum = 0; !stop_enum;
+	     stop_enum = __next_enum(&edev, &efunc, &retry)) {
+		if (kthread_should_stop())
+			break;
+		stat = __do_one_enum(mdev, edev, efunc, &r);
+		if (!r) {
+			dev_err(&mdev->dev, "no request\n");
+			continue;
+		}
+		if (stat < 0) {
+			if (!r)
+				continue;
+			if (r->status == -ETIMEDOUT) {
+				/* No reply from target */
+				retry = retry == -1 ? MAX_ENUM_RETRIES :
+					retry - 1;
+				dev_dbg(&mdev->dev, "enum timeout %u.%u\n",
+					edev, efunc);
+				continue;
+			}
+			dev_err(&mdev->dev,
+				"error %d on enum of %u.%u\n",
+				r->status == -ETIMEDOUT ? r->status :
+				r->data[0], edev, efunc);
+			mcuio_free_request(r);
+			continue;
+		}
+		retry = -1;
+		/*
+		  Found a new devices, let's add it
+		*/
+		__register_device(r);
+		mcuio_free_request(r);
+	}
+}
+
+static int mcuio_host_controller_probe(struct mcuio_device *mdev)
+{
+	struct mcuio_hc_data *data;
+	struct mcuio_hc_platform_data *plat;
+	struct regmap *map;
+	u32 irq;
+	int ret = -ENOMEM;
+	/* Only manage local host controllers */
+	if (mdev->device)
+		return -ENODEV;
+	plat = dev_get_platdata(&mdev->dev);
+	if (!plat) {
+		dev_err(&mdev->dev, "No platform data\n");
+		return -EINVAL;
+	}
+	map = plat->setup_regmap(&mdev->dev, plat);
+	if (IS_ERR(map)) {
+		dev_err(&mdev->dev, "Error setting up regmap for device\n");
+		return PTR_ERR(map);
+	}
+	data = devm_kzalloc(&mdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return ret;
+	dev_set_drvdata(&mdev->dev, data);
+	atomic_set(&data->removing, 0);
+	mutex_init(&data->lock);
+	data->mdev = mdev;
+	kthread_init_worker(&data->tx_kworker);
+	init_waitqueue_head(&data->rd_wq);
+	ret = regmap_read(map, MCUIO_IRQ, &irq);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "Error %d reading irq number\n", ret);
+		return ret;
+	}
+	ret = devm_request_threaded_irq(&mdev->dev, irq, NULL,
+					hc_irq_handler,
+					IRQF_ONESHOT,
+					dev_name(&mdev->dev), mdev);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "Error %d requesting irq\n", ret);
+		return ret;
+	}
+	data->tx_kworker_task = kthread_run(kthread_worker_fn,
+					    &data->tx_kworker,
+					    "%s_%s",
+					    dev_name(&mdev->dev), "tx");
+	if (IS_ERR(data->tx_kworker_task)) {
+		dev_err(&mdev->dev, "failed to create message tx task\n");
+		return -ENOMEM;
+	}
+	kthread_init_work(&data->send_messages, __send_messages);
+	INIT_LIST_HEAD(&data->request_queue);
+	INIT_LIST_HEAD(&data->pending_requests);
+	data->rx_thread = kthread_run(__receive_messages, mdev, "%s_%s",
+				      dev_name(&mdev->dev), "rx");
+	if (IS_ERR(data->rx_thread)) {
+		dev_err(&mdev->dev, "failed to create message rx task\n");
+		kthread_stop(data->tx_kworker_task);
+		return PTR_ERR(data->rx_thread);
+	}
+	kthread_init_worker(&data->enum_kworker);
+	data->enum_kworker_task = kthread_run(kthread_worker_fn,
+					      &data->enum_kworker,
+					      "%s_%s",
+					      dev_name(&mdev->dev), "enum");
+	if (IS_ERR(data->enum_kworker_task)) {
+		dev_err(&mdev->dev, "failed to create enum task\n");
+		return -ENOMEM;
+	}
+	kthread_init_work(&data->do_enum, __do_enum);
+	/* Immediately start enum */
+	kthread_queue_work(&data->enum_kworker, &data->do_enum);
+	return 0;
+}
+
+static void __cleanup_outstanding_requests(struct mcuio_hc_data *data)
+{
+	struct mcuio_request *r, *tmp;
+	list_for_each_entry_safe(r, tmp, &data->pending_requests, list) {
+		pr_debug("%s %d: freeing request %p\n", __func__,
+			 __LINE__, r);
+		cancel_delayed_work_sync(&r->to_work);
+		r->status = -ECANCELED;
+		if (r->cb)
+			r->cb(r);
+		__dequeue_request(r);
+	}
+}
+
+static int mcuio_host_controller_remove(struct mcuio_device *mdev)
+{
+	struct mcuio_hc_data *data = dev_get_drvdata(&mdev->dev);
+	atomic_set(&data->removing, 1);
+	barrier();
+	kthread_stop(data->enum_kworker_task);
+	kthread_stop(data->rx_thread);
+	kthread_flush_worker(&data->tx_kworker);
+	kthread_stop(data->tx_kworker_task);
+	__cleanup_outstanding_requests(data);
+	devm_kfree(&mdev->dev, data);
+	return 0;
+}
+
+static const struct mcuio_device_id hc_drv_ids[] = {
+	{
+		.class = MCUIO_CLASS_HOST_CONTROLLER,
+		.class_mask = 0xffff,
+	},
+	{
+		.class = MCUIO_CLASS_SOFT_HOST_CONTROLLER,
+		.class_mask = 0xffff,
+	},
+	/* Terminator */
+	{
+		.device = MCUIO_NO_DEVICE,
+		.class = MCUIO_CLASS_UNDEFINED,
+	},
+};
+
+static struct mcuio_driver mcuio_host_controller_driver = {
+	.driver = {
+		.name = "mcuio-hc",
+	},
+	.id_table = hc_drv_ids,
+	.probe = mcuio_host_controller_probe,
+	.remove = mcuio_host_controller_remove,
+};
+
+static int __init mcuio_host_controller_init(void)
+{
+	return mcuio_driver_register(&mcuio_host_controller_driver,
+				     THIS_MODULE);
+}
+
+static void __exit mcuio_host_controller_exit(void)
+{
+	return mcuio_driver_unregister(&mcuio_host_controller_driver);
+}
+
+subsys_initcall(mcuio_host_controller_init);
+module_exit(mcuio_host_controller_exit);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO host controller driver");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/mcuio/mcuio-hc-ldisc.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-hc-ldisc.c
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2013 Dog Hunter SA
+ *
+ * Author Davide Ciminaghi
+ * GNU GPLv2
+ */
+
+/* Line discipline based mcuio host controller */
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/circ_buf.h>
+
+#include <linux/mcuio.h>
+
+#include <linux/mcuio-proto.h>
+#include <linux/mcuio-hc.h>
+#include <linux/mcuio-soft-hc.h>
+
+#include "mcuio-internal.h"
+
+/*
+ * FIXME
+ */
+#define N_MCUIO 29
+
+#define PSIZE ((int)sizeof(struct mcuio_packet))
+
+struct ldisc_priv_data {
+	struct device *dev;
+	int blen;
+	char buf[PSIZE];
+};
+
+
+
+static int mcuio_ldisc_shc_write(struct mcuio_soft_hc *shc,
+				 const u8 *ptr, unsigned int len)
+{
+	int stat = 0, count;
+	struct tty_struct *tty = shc->priv;
+
+	for (count = 0; count < len; count += stat) {
+		stat = tty->ops->write(tty, (char *)&ptr[count], len - count);
+		if (stat <= 0)
+			break;
+	}
+	return stat <= 0 ? stat : 0;
+}
+
+static const struct mcuio_soft_hc_ops ops = {
+	.write = mcuio_ldisc_shc_write,
+};
+
+/*
+ * Open ldisc: register an mcuio controller
+ */
+static int mcuio_ldisc_open(struct tty_struct *tty)
+{
+	struct ldisc_priv_data *priv;
+	struct device *dev;
+	dev = mcuio_add_soft_hc(NULL, &ops, tty);
+	if (IS_ERR(dev))
+		return (PTR_ERR(dev));
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->dev = dev;
+	tty->disc_data = priv;
+	return 0;
+}
+
+static void mcuio_ldisc_close(struct tty_struct *tty)
+{
+	struct ldisc_priv_data *priv = tty->disc_data;
+	if (!priv)
+		return;
+	if (!priv->dev)
+		return;
+	mcuio_del_hc_device(priv->dev);
+	tty->disc_data = NULL;
+}
+
+static int mcuio_ldisc_hangup(struct tty_struct *tty)
+{
+	mcuio_ldisc_close(tty);
+	return 0;
+}
+
+static void mcuio_ldisc_receive_buf(struct tty_struct *tty,
+				    const unsigned char *cp,
+				    char *fp, int count)
+{
+	struct ldisc_priv_data *priv = tty->disc_data;
+	struct mcuio_hc_platform_data *plat;
+	struct device *dev;
+	int i, s, togo, done;
+
+	if (!priv)
+		return;
+	dev = priv->dev;
+	plat = dev_get_platdata(dev);
+	if (!plat) {
+		WARN_ON(1);
+		return;
+	}
+	for (i = 0; i < count; i++)
+		if (fp[i]) {
+			pr_err("%s: flags for char %d = 0x%02x\n",
+			       __func__, i, (u8)fp[i]);
+		}
+
+	for (togo = count, done = 0; togo; priv->blen = 0) {
+		s = min(togo, PSIZE - priv->blen);
+		memcpy(&priv->buf[priv->blen], &cp[done], s);
+		priv->blen += s;
+		togo -= s;
+		done += s;
+		if (priv->blen < PSIZE)
+			break;
+		mcuio_soft_hc_push_chars(plat->data, priv->buf, PSIZE);
+	}
+}
+
+static struct tty_ldisc_ops mcuio_ldisc = {
+	.owner 		= THIS_MODULE,
+	.magic 		= TTY_LDISC_MAGIC,
+	.name 		= "mcuio",
+	.open 		= mcuio_ldisc_open,
+	.close	 	= mcuio_ldisc_close,
+	.hangup	 	= mcuio_ldisc_hangup,
+	.receive_buf	= mcuio_ldisc_receive_buf,
+};
+
+static int __init mcuio_ldisc_init(void)
+{
+	return tty_register_ldisc(N_MCUIO, &mcuio_ldisc);
+}
+
+static void __exit mcuio_ldisc_exit(void)
+{
+	tty_unregister_ldisc(N_MCUIO);
+}
+
+module_init(mcuio_ldisc_init);
+module_exit(mcuio_ldisc_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS_LDISC(N_MCUIO);
+MODULE_AUTHOR("Davide Ciminaghi, derived from slip ldisc implementation");
Index: linux-4.9.87/drivers/mcuio/mcuio-internal.h
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-internal.h
@@ -0,0 +1,48 @@
+#ifndef __MCUIO_INTERNAL_H__
+#define __MCUIO_INTERNAL_H__
+
+#include <linux/version.h>
+#include <linux/mcuio-proto.h>
+
+extern struct bus_type mcuio_bus_type;
+extern struct device mcuio_bus;
+extern struct attribute_group mcuio_default_dev_attr_group;
+
+int mcuio_get_bus(void);
+void mcuio_put_bus(unsigned bus);
+
+struct i2c_adapter *mcuio_get_i2c_adapter(struct mcuio_device *mdev);
+
+struct mcuio_device *mcuio_bus_find_hc(int bus);
+
+struct mcuio_device *mcuio_add_soft_local_irq_ctrl(struct mcuio_device *hc,
+						   int fn, int base_irq);
+
+#ifdef DEBUG
+static inline void dump_packet(struct mcuio_packet *p)
+{
+	int i;
+	uint8_t *ptr;
+	pr_debug("Packet dump:\n");
+	pr_debug("\t%s,%s,%s,%u:%u.%u,%s,@0x%04x",
+		 mcuio_packet_is_error(p) ? "ERR" : "NOERR" ,
+		 mcuio_packet_is_reply(p) ? "REP" : "req",
+		 mcuio_packet_is_fill_data(p) ? "[FILL]" : "[NOFILL]",
+		 mcuio_packet_bus(p), mcuio_packet_dev(p),
+		 mcuio_packet_func(p),
+		 mcuio_packet_type_to_str(mcuio_packet_type(p)),
+		 mcuio_packet_offset(p));
+	printk(KERN_DEBUG "\tpacket: ");
+	for (i = 0, ptr = (uint8_t *)p; i < 2*sizeof(uint64_t); i++)
+		printk("0x%02x ", ptr[i]);
+	printk("\n");
+}
+#else
+static inline void dump_packet(const struct mcuio_packet *packet)
+{
+
+}
+#endif
+
+
+#endif /* __MCUIO_INTERNAL_H__ */
Index: linux-4.9.87/drivers/mcuio/mcuio-irq-test.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-irq-test.c
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+
+#define DEBUG
+
+/* mcuio driver for joystick shield */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/hid.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+//#include <linux/platform_data/ssd1307.h>
+
+
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+
+#include "mcuio-internal.h"
+
+static const struct regmap_config mcuio_irq_test_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.max_register = 0x8,
+	.cache_type = REGCACHE_NONE,
+};
+
+
+static irqreturn_t mcuio_irq_test_irq_handler(int irq, void *__data)
+{
+	struct regmap *map = __data;
+	int stat;
+	u32 status;
+
+	stat = regmap_read(map, 0xc, &status);
+	WARN_ON(!status);
+
+	return IRQ_HANDLED;
+}
+
+static int mcuio_irq_test_probe(struct mcuio_device *mdev)
+{
+	int ret = 0;
+	unsigned int v = 1;
+	struct regmap *map;
+
+	dev_dbg(&mdev->dev, "%s entered\n", __func__);
+
+	map = devm_regmap_init_mcuio(mdev, &mcuio_irq_test_regmap_config);
+	if (IS_ERR(map)) {
+		dev_err(&mdev->dev, "cannot init regmap\n");
+		return PTR_ERR(map);
+	}
+
+	ret = devm_request_threaded_irq(&mdev->dev, mdev->irq,
+					NULL,
+					mcuio_irq_test_irq_handler,
+					0,
+					"mcuio-irq-test",
+					map);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read(map, 0xc, &v);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "Error cleaning up irq status\n");
+		return ret;
+	}
+
+	/* Immediately enable interrupt */
+	ret = regmap_write(map, 0xc, 1);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "Error enabling interrupt\n");
+		return ret;
+	}
+
+
+	dev_set_drvdata(&mdev->dev, map);
+
+	dev_dbg(&mdev->dev, "%s returns ok\n", __func__);
+
+	return ret;
+}
+
+static int mcuio_irq_test_remove(struct mcuio_device *mdev)
+{
+	int ret;
+	unsigned int v = 0;
+	struct regmap *map;
+
+	map = dev_get_drvdata(&mdev->dev);
+
+	ret = regmap_write(map, 0xc, v);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "Error stopping irq tester\n");
+		return ret;
+	}
+	return 0;
+}
+
+static const struct mcuio_device_id irq_test_drv_ids[] = {
+	{
+		.vendor = MCUIO_VENDOR_DOGHUNTER,
+		.device = 0x1212,
+	},
+	/* Terminator */
+	{
+		.device = MCUIO_NO_DEVICE,
+		.class = MCUIO_CLASS_UNDEFINED,
+	},
+};
+
+static struct mcuio_driver mcuio_irq_test_driver = {
+	.driver = {
+		.name = "mcuio-irq-test",
+	},
+	.id_table = irq_test_drv_ids,
+	.probe = mcuio_irq_test_probe,
+	.remove = mcuio_irq_test_remove,
+};
+
+static int __init mcuio_irq_test_init(void)
+{
+	return mcuio_driver_register(&mcuio_irq_test_driver, THIS_MODULE);
+}
+
+static void __exit mcuio_irq_test_exit(void)
+{
+	return mcuio_driver_unregister(&mcuio_irq_test_driver);
+}
+
+subsys_initcall(mcuio_irq_test_init);
+module_exit(mcuio_irq_test_exit);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO driver for irq test function");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/mcuio/mcuio-soft-hc.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-soft-hc.c
@@ -0,0 +1,369 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+
+/* mcuio generic soft host controller functions */
+
+#include <linux/mcuio.h>
+#include <linux/circ_buf.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/regmap.h>
+#include <linux/err.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/circ_buf.h>
+#include <linux/mcuio_ids.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio-proto.h>
+#include <linux/mcuio-hc.h>
+#include <linux/mcuio-soft-hc.h>
+#include "mcuio-internal.h"
+
+static struct notifier_block device_nb;
+
+static bool mcuio_soft_hc_readable(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static bool mcuio_soft_hc_writeable(struct device *dev, unsigned int reg)
+{
+	return (reg >= MCUIO_HC_OUTBUF && reg < MCUIO_HC_INBUF) ||
+		reg == MCUIO_IRQ_CLR;
+	return true;
+}
+
+/*
+ * regmap config for line discipline based mcuio host controller
+ */
+static struct regmap_config proto = {
+	.name = "mcuio-ldisc",
+	.reg_bits = 8,
+	.val_bits = 32,
+	.max_register = MCUIO_HC_MAX_REGISTER,
+	.readable_reg = mcuio_soft_hc_readable,
+	.writeable_reg = mcuio_soft_hc_writeable,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int mcuio_soft_hc_read_inbuf(struct mcuio_soft_hc *shc,
+			       unsigned int reg,
+			       unsigned int *val)
+{
+	int i, s = sizeof(shc->rx_buf);
+	u8 *out = (u8 *)val;
+	struct circ_buf *buf = &shc->rx_circ_buf;
+
+	if (CIRC_CNT(buf->head, buf->tail, s) < sizeof(u32))
+		return -EAGAIN;
+	for (i = 0; i < sizeof(u32); i++) {
+		out[i] = buf->buf[buf->tail++];
+		buf->tail &= (s - 1);
+	}
+	return sizeof(unsigned int);
+}
+
+static int mcuio_soft_hc_reg_read(void *context, unsigned int reg,
+				  unsigned int *val)
+{
+	struct mcuio_soft_hc *shc = context;
+	if (!shc)
+		return -EINVAL;
+	if (reg >= MCUIO_HC_INBUF && reg < MCUIO_RX_CNT)
+		return mcuio_soft_hc_read_inbuf(shc, reg, val);
+	switch(reg) {
+	case MCUIO_RX_CNT:
+	{
+		struct circ_buf *buf = &shc->rx_circ_buf;
+		*val = CIRC_CNT(buf->head, buf->tail, sizeof(shc->rx_buf));
+		return sizeof(*val);
+	}
+	case MCUIO_IRQ:
+		*val = shc->irqno;
+		return sizeof(*val);
+	case MCUIO_IRQ_STAT:
+	{
+		struct circ_buf *buf = &shc->rx_circ_buf;
+		unsigned int new_irqstat;
+
+		*val = shc->irqstat;
+
+		pr_debug("%s: autoclear shc irqstat\n", __func__);
+		new_irqstat = CIRC_CNT(buf->head, buf->tail,
+				       sizeof(shc->rx_buf)) ? RX_RDY : 0;
+		shc->irqstat = new_irqstat;
+		pr_debug("%s: new shc irqstat = 0x%08x\n", __func__,
+			shc->irqstat);
+		return sizeof(*val);
+	}
+	default:
+		return -EPERM;
+	}
+	/* NEVER REACHED */
+	return -EPERM;
+}
+
+static int mcuio_soft_hc_reg_write(void *context,
+				   unsigned int reg, unsigned int val)
+{
+	struct mcuio_soft_hc *shc = context;
+	u8 *out = (u8 *)&val;
+	if (!shc)
+		return -EINVAL;
+	if (reg >= MCUIO_HC_OUTBUF && reg < MCUIO_HC_INBUF)
+		return shc->ops->write(shc, out, sizeof(val));
+	if (reg == MCUIO_IRQ_CLR) {
+		shc->irqstat &= ~val;
+		return 0;
+	}
+	return -EPERM;
+}
+
+int mcuio_soft_hc_push_chars(struct mcuio_soft_hc *shc, const u8 *in, int len)
+{
+	int s = sizeof(shc->rx_buf), available, actual;
+	struct circ_buf *buf = &shc->rx_circ_buf;
+	available = CIRC_SPACE_TO_END(buf->head, buf->tail, s);
+	if (available < sizeof(u32)) {
+		pr_debug("%s %d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+	actual = min(len, available);
+	memcpy(&buf->buf[buf->head], in, actual);
+	buf->head = (buf->head + actual) & (s - 1);
+	/* set irq status register RX_RDY bit */
+	shc->irqstat |= RX_RDY;
+	if (shc->irq_enabled)
+		kthread_queue_work(&shc->irq_kworker, &shc->do_irq);
+	return actual;
+}
+EXPORT_SYMBOL(mcuio_soft_hc_push_chars);
+
+static struct regmap_config *mcuio_soft_hc_setup_regmap_config(void)
+{
+	struct regmap_config *out = kzalloc(sizeof(*out), GFP_KERNEL);
+	if (!out)
+		return out;
+	*out = proto;
+	out->reg_read = mcuio_soft_hc_reg_read;
+	out->reg_write = mcuio_soft_hc_reg_write;
+	return out;
+}
+
+static struct regmap *
+mcuio_soft_hc_setup_regmap(struct device *dev,
+			   void *__plat)
+{
+	struct mcuio_hc_platform_data *plat = __plat;
+	struct regmap_config *map_cfg = mcuio_soft_hc_setup_regmap_config();
+	struct mcuio_soft_hc *shc;
+	struct regmap *out = ERR_PTR(-ENOMEM);
+	if (!map_cfg) {
+		dev_err(dev, "%s: cannot setup regmap config\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+	shc = plat->data;
+	if (!shc) {
+		dev_err(dev, "%s: no platform data\n", __func__);
+		return out;
+	}
+	/*
+	  no_bus regmap with reg_read and reg_write, use soft controller
+	  structure as regmap context
+	*/
+	return regmap_init(dev, NULL, shc, map_cfg);
+}
+
+static void mcuio_soft_hc_irq_mask(struct irq_data *d)
+{
+	struct irq_chip *chip = irq_data_get_irq_chip(d);
+	struct mcuio_soft_hc *shc =
+		container_of(chip, struct mcuio_soft_hc, chip);
+
+	shc->irq_enabled = 0;
+}
+
+static void mcuio_soft_hc_irq_unmask(struct irq_data *d)
+{
+	struct irq_chip *chip = irq_data_get_irq_chip(d);
+	struct mcuio_soft_hc *shc =
+		container_of(chip, struct mcuio_soft_hc, chip);
+
+	shc->irq_enabled = 1;
+}
+
+static void __do_irq(struct kthread_work *work)
+{
+	struct mcuio_soft_hc *shc =
+		container_of(work, struct mcuio_soft_hc, do_irq);
+
+	handle_nested_irq(shc->irqno);
+}
+
+static struct mcuio_soft_hc *__setup_shc(const struct mcuio_soft_hc_ops *ops,
+					 void *priv)
+{
+	struct mcuio_soft_hc *shc = kzalloc(sizeof(*shc), GFP_KERNEL);
+	if (!shc)
+		return ERR_PTR(-ENOMEM);
+	kthread_init_worker(&shc->irq_kworker);
+	shc->irq_kworker_task = kthread_run(kthread_worker_fn,
+					    &shc->irq_kworker,
+					    "shc_irq");
+	if (IS_ERR(shc->irq_kworker_task)) {
+		pr_err("failed to create irq tsk for shc\n");
+		return ERR_PTR(PTR_ERR(shc->irq_kworker_task));
+	}
+	kthread_init_work(&shc->do_irq, __do_irq);
+	shc->ops = ops;
+	shc->priv = priv;
+	shc->rx_circ_buf.head = shc->rx_circ_buf.tail = 0;
+	shc->rx_circ_buf.buf = shc->rx_buf;
+	shc->chip.name = "MCUIO-SHC";
+	shc->chip.irq_mask = mcuio_soft_hc_irq_mask;
+	shc->chip.irq_unmask = mcuio_soft_hc_irq_unmask;
+	shc->irqno = irq_alloc_desc(0);
+	irq_set_chip(shc->irqno, &shc->chip);
+	irq_set_handler(shc->irqno, &handle_simple_irq);
+	irq_modify_status(shc->irqno,
+			  IRQ_NOREQUEST | IRQ_NOAUTOEN,
+			  IRQ_NOPROBE);
+	return shc;
+}
+
+static struct mcuio_device_id default_soft_hc_id = {
+	.device = MCUIO_DEVICE_SOFT_HC,
+	.vendor = MCUIO_VENDOR_DOGHUNTER,
+	.class = MCUIO_CLASS_SOFT_HOST_CONTROLLER,
+};
+
+static void mcuio_soft_hc_release(struct device *device)
+{
+	struct mcuio_hc_platform_data *plat = dev_get_platdata(device);
+	struct mcuio_soft_hc *shc;
+	int i;
+	if (!plat) {
+		WARN_ON(1);
+		return;
+	}
+	shc = plat->data;
+	bus_unregister_notifier(&mcuio_bus_type, &device_nb);
+	/* Unregister all irq controllers */
+	for (i = 0; i < MCUIO_DEVS_PER_BUS; i++)
+		if (shc->irq_controllers[i])
+			mcuio_device_unregister(shc->irq_controllers[i]);
+	irq_set_handler(shc->irqno, NULL);
+	irq_set_chip(shc->irqno, NULL);
+	irq_free_desc(shc->irqno);
+	kfree(shc);
+	mcuio_hc_dev_default_release(device);
+}
+
+static void __device_added(struct device *dev)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	struct mcuio_device *hc;
+	struct mcuio_soft_hc *shc;
+	struct mcuio_device *ic;
+	struct mcuio_hc_platform_data *plat;
+	int base_irq;
+
+	/* Ignore the hc */
+	if (!mdev->device)
+		return;
+	hc = to_mcuio_dev(dev->parent);
+	plat = dev_get_platdata(&hc->dev);
+	if (!plat) {
+		WARN_ON(1);
+		return;
+	}
+	shc = plat->data;
+	if (!shc) {
+		WARN_ON(1);
+		return;
+	}
+	/* FIXME: ADD LOCKING */
+	ic = shc->irq_controllers[mdev->device];
+	if (ic)
+		return;
+	base_irq = irq_alloc_descs(-1, 0, MCUIO_FUNCS_PER_DEV, 0);
+	/* New device, add soft local irq controller */
+	ic = mcuio_add_soft_local_irq_ctrl(hc, mdev->device, base_irq);
+	if (!ic) {
+		pr_err("mcuio soft hc: error adding irq ctrl for dev %d\n",
+		       mdev->device);
+		return;
+	}
+	shc->irq_controllers[mdev->device] = ic;
+	/*
+	  This is the first function of the new device. When the corresponding
+	  mcuio_device was instantiated, the hc had no irqs, fix the field
+	  up now
+	*/
+	mdev->irq = base_irq + mdev->fn;
+}
+
+static int mcuio_add_notifier(struct notifier_block *nb,
+			      unsigned long action, void *data)
+{
+	struct device *dev = data;
+
+	switch (action) {
+	case BUS_NOTIFY_ADD_DEVICE:
+		__device_added(dev);
+		break;
+	default:
+		return NOTIFY_DONE;
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block device_nb = {
+	.notifier_call = mcuio_add_notifier,
+};
+
+struct device *mcuio_add_soft_hc(struct mcuio_device_id *id,
+				 const struct mcuio_soft_hc_ops *ops,
+				 void *priv)
+{
+	struct mcuio_hc_platform_data *plat;
+	struct mcuio_soft_hc *shc = __setup_shc(ops, priv);
+	struct device *out;
+	int stat;
+	if (IS_ERR(shc))
+		return ERR_PTR(PTR_ERR(shc));
+	plat = kzalloc(sizeof(*plat), GFP_KERNEL);
+	if (!plat) {
+		kfree(shc);
+		return ERR_PTR(-ENOMEM);
+	}
+	plat->setup_regmap = mcuio_soft_hc_setup_regmap;
+	plat->data = shc;
+
+	stat = bus_register_notifier(&mcuio_bus_type, &device_nb);
+	if (stat < 0) {
+		kfree(shc);
+		return ERR_PTR(stat);
+	}
+
+	out = mcuio_add_hc_device(id ? id : &default_soft_hc_id, plat,
+				  mcuio_soft_hc_release);
+	if (IS_ERR(out)) {
+		kfree(shc);
+		bus_unregister_notifier(&mcuio_bus_type, &device_nb);
+		return out;
+	}
+	shc->hc = to_mcuio_dev(out);
+	return out;
+}
+EXPORT_SYMBOL(mcuio_add_soft_hc);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO soft host controller code");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/mcuio/mcuio-soft-local-irq-ctrl-msg-dev.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-soft-local-irq-ctrl-msg-dev.c
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+/* #define DEBUG */
+
+/* MCUIO local msg irq controller device */
+/*
+ * This module implements a soft local irq controller device, which is
+ * instantiated by the soft hc controller.
+ * Actual interrupts are triggered by remote device write accesses to
+ * this device.
+ *
+ *  +---------------------+          +----------------------+
+ *  |MPU                  |          | MCU                  |
+ *  |                     |          |                      |
+ *  |          +------------------------+                   |
+ *  |          V wr@0xXXX |          |  |                   |
+ *  |+----------------+   |          |+--------------+      |
+ *  || local irq ctrl |   |          ||irq ctrl msg  |      |
+ *  |+----------------+   |          |+--------------+      |
+ *  +---------------------+          +----------------------+
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio-hc.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-proto.h>
+
+#include "mcuio-internal.h"
+
+/* Interrupt messages */
+#define MCUIO_IRQ_TRIGGER 0xf80
+
+/*
+ * Data concerning irq of a single function
+ *
+ * @irq_kwork: kthread_worker for irq generation
+ * @irq_kworker_task: irq generation task
+ * @do_irq: kthread_work for irq generation
+ */
+struct fn_irqdata {
+	struct kthread_worker irq_kworker;
+	struct task_struct *irq_kworker_task;
+	struct kthread_work do_irq;
+	int irq;
+};
+
+/*
+ * private data for message based soft local irq controller
+ */
+struct soft_local_irq_ctrl_msg {
+	struct mcuio_device mdev;
+	struct mcuio_request write_req;
+	struct irq_chip chip;
+	int base_irq;
+	struct fn_irqdata irqdata[MCUIO_FUNCS_PER_DEV];
+	atomic_t removing;
+};
+
+static const struct attribute_group *soft_local_irq_ctrl_dev_attr_groups[] = {
+	&mcuio_default_dev_attr_group,
+	NULL,
+};
+
+void mcuio_soft_local_irq_ctrl_release(struct device *dev)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	struct soft_local_irq_ctrl_msg *slicm =
+		container_of(mdev, struct soft_local_irq_ctrl_msg, mdev);
+	int i;
+
+	pr_debug("%s entered\n", __func__);
+	atomic_set(&slicm->removing, 1);
+	pr_debug("canceling write req cb\n");
+	mcuio_cancel_cb(&slicm->write_req);
+	for (i = 0; i < MCUIO_FUNCS_PER_DEV; i++) {
+		struct fn_irqdata *idata = &slicm->irqdata[i];
+
+		pr_debug("stopping thread for device %d\n", i);
+		kthread_flush_worker(&idata->irq_kworker);
+		kthread_stop(idata->irq_kworker_task);
+	}
+	pr_debug("freeing irq descriptors\n");
+	irq_free_descs(slicm->base_irq, MCUIO_FUNCS_PER_DEV);
+	kfree(slicm);
+}
+
+
+static struct device_type mcuio_soft_local_irq_ctrl_device_type = {
+	.name = "mcuio-soft-local-irq-ctrl",
+	.groups = soft_local_irq_ctrl_dev_attr_groups,
+	.release = mcuio_soft_local_irq_ctrl_release,
+};
+
+static void mcuio_soft_local_irq_controller_msg_wcb(struct mcuio_request *r)
+{
+	struct soft_local_irq_ctrl_msg *slicm = r->cb_data;
+	struct fn_irqdata *idata;
+	int fn;
+
+	pr_debug("%s %d, offset = 0x%04x, data[0] = 0x%08x\n",
+		 __func__, __LINE__, r->offset, r->data[0]);
+
+	if (atomic_read(&slicm->removing))
+		return;
+
+	fn = (r->offset - MCUIO_IRQ_TRIGGER) / sizeof(u32);
+
+	if ((fn < 0) || (fn >= MCUIO_FUNCS_PER_DEV)) {
+		if (r->status != -ECANCELED)
+			dev_err(&slicm->mdev.dev, "UNHANDLED WRITE REQ TO 0x%04x\n",
+				r->offset);
+		return;
+	}
+
+	idata = &slicm->irqdata[fn];
+
+	kthread_queue_work(&idata->irq_kworker, &idata->do_irq);
+}
+
+static void mcuio_soft_local_irq_mask(struct irq_data *d)
+{
+}
+
+static void mcuio_soft_local_irq_unmask(struct irq_data *d)
+{
+}
+
+static void __do_irq(struct kthread_work *work)
+{
+	struct fn_irqdata *idata =
+		container_of(work, struct fn_irqdata, do_irq);
+
+	handle_nested_irq(idata->irq);
+}
+
+struct mcuio_device *
+mcuio_add_soft_local_irq_ctrl(struct mcuio_device *hc, int fn, int base_irq)
+{
+	struct soft_local_irq_ctrl_msg *slicm = kzalloc(sizeof(*slicm),
+							GFP_KERNEL);
+	struct mcuio_device *out, *mdev;
+	int i, ret, dev_irqs[MCUIO_FUNCS_PER_DEV];
+
+	pr_debug("%s entered\n", __func__);
+	if (!slicm) {
+		dev_err(&hc->dev, "error allocating soft local irq struct\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	mdev = &slicm->mdev;
+	slicm->chip.name = "MCUIO-SOFT-LOCAL-IRQ-CTRL";
+	slicm->chip.irq_mask = mcuio_soft_local_irq_mask;
+	slicm->chip.irq_unmask = mcuio_soft_local_irq_unmask;
+	slicm->base_irq = base_irq;
+
+	for (i = 0; i < MCUIO_FUNCS_PER_DEV; i++) {
+		int irq = slicm->base_irq + i;
+		struct fn_irqdata *idata = &slicm->irqdata[i];
+
+		irq_set_chip_data(irq, slicm);
+		irq_set_handler_data(irq, idata);
+		irq_set_chip(irq, &slicm->chip);
+		irq_set_handler(irq, &handle_simple_irq);
+		irq_modify_status(irq,
+				  IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);
+		dev_irqs[i] = irq;
+
+		idata->irq = irq;
+		kthread_init_worker(&idata->irq_kworker);
+		idata->irq_kworker_task = kthread_run(kthread_worker_fn,
+						      &idata->irq_kworker,
+						      "mcuio_irq_%d_%d",
+						      fn, i);
+		if (IS_ERR(idata->irq_kworker_task)) {
+			int j;
+
+			pr_err("failed to create irq tsk for %d, fn %d\n",
+			       hc->device, i);
+			mdev = ERR_PTR(PTR_ERR(idata->irq_kworker_task));
+			for (j = 0; j < i; j++) {
+				idata = &slicm->irqdata[j];
+				kthread_stop(idata->irq_kworker_task);
+			}
+			break;
+		}
+		kthread_init_work(&idata->do_irq, __do_irq);
+	}
+	if (IS_ERR(mdev)) {
+		out = mdev;
+		goto err0;
+	}
+	mdev->id.device = MCUIO_DEVICE_LOCAL_IRQC_MSG;
+	mdev->id.vendor = MCUIO_VENDOR_DOGHUNTER;
+	mdev->id.class = MCUIO_CLASS_SOFT_LOCAL_IRQ_CONTROLLER_PROTO;
+	mdev->id.class_mask = 0xffffffff;
+	mdev->bus = hc->bus;
+	/* Local device */
+	mdev->device = 0;
+	mdev->fn = fn;
+	pr_debug("%s %d, device = 0x%04x, vendor = 0x%04x, "
+		 "class = 0x%04x\n", __func__, __LINE__, mdev->id.device,
+		 mdev->id.vendor, mdev->id.class);
+
+	/*
+	 * Register a callback for write requests to this device
+	 * over the mcuio bus
+	 */
+	slicm->write_req.cb = mcuio_soft_local_irq_controller_msg_wcb;
+	slicm->write_req.cb_data = slicm;
+
+	mcuio_init_request(&slicm->write_req, hc, mdev->device, mdev->fn,
+			   mcuio_type_wrdw, 0, 0, 0);
+
+	ret = mcuio_setup_cb(&slicm->write_req);
+	if (ret < 0) {
+		dev_err(&hc->dev, "error setting up write callback\n");
+		out = ERR_PTR(ret);
+		goto err0;
+	}
+
+	/*
+	 * The hc is not our parent
+	 */
+	ret = mcuio_device_register(mdev,
+				    &mcuio_soft_local_irq_ctrl_device_type,
+				    NULL);
+	if (ret < 0) {
+		dev_err(&hc->dev,
+			"error registering device %u:%u.%u\n", hc->bus, 0, fn);
+		out = ERR_PTR(ret);
+		goto err1;
+	}
+
+	ret = mcuio_hc_set_irqs(hc, fn, dev_irqs);
+	if (ret < 0) {
+		dev_err(&hc->dev, "error setting irqs\n");
+		mcuio_device_unregister(mdev);
+		out = ERR_PTR(ret);
+		goto err1;
+	}
+
+	out = mdev;
+
+	pr_debug("%s successful, created device %s\n",
+		 __func__, dev_name(&out->dev));
+
+	return out;
+
+
+err1:
+	mcuio_cancel_cb(&slicm->write_req);
+err0:
+	irq_free_descs(slicm->base_irq, MCUIO_FUNCS_PER_DEV);
+	kfree(mdev);
+	return out;
+}
+EXPORT_SYMBOL(mcuio_add_soft_local_irq_ctrl);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO irq controller driver");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/mcuio/sysfs.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/sysfs.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sysfs.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include "mcuio-internal.h"
+
+
+static ssize_t show_device(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	return sprintf(buf, "0x%04x", mdev->id.device);
+}
+
+static ssize_t show_vendor(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	return sprintf(buf, "0x%04x", mdev->id.vendor);
+}
+
+static ssize_t show_class(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	return sprintf(buf, "0x%08x", mdev->id.class);
+}
+
+static ssize_t show_bus(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	return sprintf(buf, "%u", mdev->bus);
+}
+
+static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	return sprintf(buf, "%u", mdev->device);
+}
+
+static ssize_t show_func(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct mcuio_device *mdev = to_mcuio_dev(dev);
+	return sprintf(buf, "%u", mdev->fn);
+}
+
+static DEVICE_ATTR(device, 0444, show_device, NULL);
+static DEVICE_ATTR(vendor, 0444, show_vendor, NULL);
+static DEVICE_ATTR(class, 0444, show_class, NULL);
+static DEVICE_ATTR(bus, 0444, show_bus, NULL);
+static DEVICE_ATTR(dev, 0444, show_dev, NULL);
+static DEVICE_ATTR(func, 0444, show_func, NULL);
+
+static struct attribute *dev_attrs[] = {
+	&dev_attr_device.attr,
+	&dev_attr_vendor.attr,
+	&dev_attr_class.attr,
+	&dev_attr_bus.attr,
+	&dev_attr_dev.attr,
+	&dev_attr_func.attr,
+	NULL,
+};
+
+struct attribute_group mcuio_default_dev_attr_group = {
+	.attrs = dev_attrs,
+};
+EXPORT_SYMBOL(mcuio_default_dev_attr_group);
Index: linux-4.9.87/drivers/Kconfig
===================================================================
--- linux-4.9.87.orig/drivers/Kconfig
+++ linux-4.9.87/drivers/Kconfig
@@ -202,4 +202,6 @@ source "drivers/hwtracing/intel_th/Kconf
 
 source "drivers/fpga/Kconfig"
 
+source "drivers/mcuio/Kconfig"
+
 endmenu
Index: linux-4.9.87/drivers/Makefile
===================================================================
--- linux-4.9.87.orig/drivers/Makefile
+++ linux-4.9.87/drivers/Makefile
@@ -175,3 +175,4 @@ obj-$(CONFIG_STM)		+= hwtracing/stm/
 obj-$(CONFIG_ANDROID)		+= android/
 obj-$(CONFIG_NVMEM)		+= nvmem/
 obj-$(CONFIG_FPGA)		+= fpga/
+obj-$(CONFIG_MCUIO)		+= mcuio/
Index: linux-4.9.87/drivers/base/regmap/regmap-mcuio-remote.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/base/regmap/regmap-mcuio-remote.c
@@ -0,0 +1,259 @@
+/*
+ * Regmap for remote mcuio devices (not living on this machine)
+ * Presently, all mcuio devices are remote devices except for the ho
+ * controller. Code comes from regmap-mmio
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio-proto.h>
+
+#define MAX_RETRIES 3
+
+/**
+ * mcuio bus context
+ * @hc: pointer to host controller
+ * @dev: device number of mcuio device
+ * @func: function number of mcuio device
+ */
+struct regmap_mcuio_context {
+	struct mcuio_device *hc;
+	unsigned dev;
+	unsigned func;
+	unsigned val_bytes;
+};
+
+static int regmap_mcuio_gather_write(void *context,
+				     const void *reg, size_t reg_size,
+				     const void *val, size_t val_size)
+{
+	struct regmap_mcuio_context *ctx = context;
+	struct mcuio_request r;
+	u32 offset;
+	unsigned t;
+	int ret = 0;
+	int retries = MAX_RETRIES;
+
+	BUG_ON(reg_size != 4);
+
+	offset = *(u32 *)reg;
+
+	r.hc = ctx->hc;
+	r.dev = ctx->dev;
+	r.func = ctx->func;
+	r.offset = offset;
+
+	switch (ctx->val_bytes) {
+	case 1:
+		t = mcuio_type_wrb;
+		break;
+	case 2:
+		t = mcuio_type_wrw;
+		break;
+	case 4:
+		t = mcuio_type_wrdw;
+		break;
+	case 8:
+		t = mcuio_type_wrq;
+		break;
+	default:
+		BUG();
+	}
+
+	while (val_size && retries) {
+		int sz = ctx->val_bytes, fill = 0;
+
+		if (val_size >= sizeof(u64)) {
+			fill = 1;
+			sz = sizeof(u64);
+		}
+		memcpy(r.data, val, sz);
+		mcuio_init_request(&r, ctx->hc, ctx->dev, ctx->func,
+				   t, fill, offset, 0xffff);
+		ret = mcuio_submit_request(&r);
+		if (ret == -ETIMEDOUT) {
+			retries--;
+			continue;
+		}
+		if (ret)
+			break;
+		val_size -= sz;
+		val += sz;
+		offset += sz;
+	}
+
+	return ret;
+}
+
+static int regmap_mcuio_write(void *context, const void *data, size_t count)
+{
+	BUG_ON(count < 4);
+
+	return regmap_mcuio_gather_write(context, data, 4, data + 4, count - 4);
+}
+
+static int regmap_mcuio_read(void *context,
+			     const void *reg, size_t reg_size,
+			     void *val, size_t val_size)
+{
+	struct regmap_mcuio_context *ctx = context;
+	struct mcuio_request r;
+	u32 offset = *(u32 *)reg;
+	int ret = 0;
+	unsigned t;
+	int retries = MAX_RETRIES;
+
+	BUG_ON(reg_size != 4);
+	
+	switch (ctx->val_bytes) {
+	case 1:
+		t = mcuio_type_rdb;
+		break;
+	case 2:
+		t = mcuio_type_rdw;
+		break;
+	case 4:
+		t = mcuio_type_rddw;
+		break;
+	case 8:
+		t = mcuio_type_rdq;
+		break;
+	default:
+		return -EINVAL;
+	}
+	while (val_size && retries) {
+		int sz = ctx->val_bytes, fill = 0;
+
+		fill = 0;
+		if (val_size >= sizeof(u64)) {
+			fill = 1;
+			sz = sizeof(u64);
+		}
+		mcuio_init_request(&r, ctx->hc, ctx->dev, ctx->func, t,
+				   fill, offset, 0xffff);
+		ret = mcuio_submit_request(&r);
+		if (ret == -ETIMEDOUT) {
+			retries--;
+			continue;
+		}
+		if (ret)
+			break;
+		memcpy(val, r.data, sz);
+		val_size -= sz;
+		val += sz;
+		offset += sz;
+	}
+	return ret;
+}
+
+
+static void regmap_mcuio_free_context(void *context)
+{
+	struct regmap_mcuio_context *ctx = context;
+	kfree(ctx);
+}
+
+static struct regmap_bus regmap_mcuio = {
+	.write = regmap_mcuio_write,
+	.read = regmap_mcuio_read,
+	.free_context = regmap_mcuio_free_context,
+};
+
+static struct regmap_mcuio_context *
+regmap_mcuio_setup_context(struct mcuio_device *mdev,
+			   const struct regmap_config *config)
+{
+	struct mcuio_device *hc = to_mcuio_dev(mdev->dev.parent);
+	struct regmap_mcuio_context *ctx;
+	int min_stride;
+
+	if (config->reg_bits != 32)
+		return ERR_PTR(-EINVAL);
+
+	switch (config->val_bits) {
+	case 8:
+		/* The core treats 0 as 1 */
+		min_stride = 0;
+		break;
+	case 16:
+		min_stride = 2;
+		break;
+	case 32:
+		min_stride = 4;
+		break;
+#ifdef CONFIG_64BIT
+	case 64:
+		min_stride = 8;
+		break;
+#endif
+		break;
+	default:
+		return ERR_PTR(-EINVAL);
+	}
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return ERR_PTR(-ENOMEM);
+
+	ctx->hc = hc;
+	ctx->dev = mdev->device;
+	ctx->func = mdev->fn;
+	ctx->val_bytes = config->val_bits / 8;
+	return ctx;
+}
+
+
+/**
+ * regmap_init_mcuio(): Initialise mcuio register map
+ *
+ * @dev: Device that will be interacted with
+ * @hc: mcuio system controller
+ * @config: Configuration for register map
+ *
+ * The return value will be an ERR_PTR() on error or a valid pointer to
+ * a struct regmap.
+ */
+struct regmap *regmap_init_mcuio(struct mcuio_device *mdev,
+				 const struct regmap_config *config)
+{
+	struct regmap_mcuio_context *ctx;
+	ctx = regmap_mcuio_setup_context(mdev, config);
+	if (IS_ERR(ctx))
+		return ERR_CAST(ctx);
+
+	return regmap_init(&mdev->dev, &regmap_mcuio, ctx, config);
+}
+EXPORT_SYMBOL_GPL(regmap_init_mcuio);
+
+/**
+ * devm_regmap_init_mcuio(): Initialise mcuio register map, device manage
+ * version
+ *
+ * @dev: Device that will be interacted with
+ * @hc: mcuio system controller
+ * @config: Configuration for register map
+ *
+ * The return value will be an ERR_PTR() on error or a valid pointer to
+ * a struct regmap.
+ */
+struct regmap *devm_regmap_init_mcuio(struct mcuio_device *mdev,
+				      const struct regmap_config *config)
+{
+	struct regmap_mcuio_context *ctx;
+	ctx = regmap_mcuio_setup_context(mdev, config);
+	if (IS_ERR(ctx))
+		return ERR_CAST(ctx);
+
+	return devm_regmap_init(&mdev->dev, &regmap_mcuio, ctx, config);
+}
+EXPORT_SYMBOL_GPL(devm_regmap_init_mcuio);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO bus regmap implementation");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/gpio/gpio-mcuio.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/gpio/gpio-mcuio.c
@@ -0,0 +1,393 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+/* #define DEBUG */
+
+/* mcuio host controller driver */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-proto.h>
+
+struct mcuio_gpio {
+	struct regmap		*map;
+	struct gpio_chip	chip;
+	struct irq_chip		irqchip;
+	int			irq_base;
+	u32			out[2];
+	char			label[20];
+	struct			work_struct irq_work;
+	int			irq_work_pending;
+	uint32_t		status[2];
+};
+
+static int mcuio_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct mcuio_gpio *gpio = container_of(chip, struct mcuio_gpio, chip);
+	struct regmap *map = gpio->map;
+	int roffset = offset / 32;
+	u32 mask = 1 << (offset - (roffset * 32));
+	u32 in;
+
+	pr_debug("%s invoked, offset = %u\n", __func__, offset);
+	regmap_read(map, 0x910 + roffset * sizeof(u32), &in);
+	pr_debug("%s: in = 0x%08x\n", __func__, in);
+	return in & mask ? 1 : 0;
+}
+
+static void mcuio_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct mcuio_gpio *gpio = container_of(chip, struct mcuio_gpio, chip);
+	struct regmap *map = gpio->map;
+	int roffset = offset / 32;
+	u32 mask = 1 << (offset - (roffset * 32));
+	gpio->out[roffset] &= ~mask;
+	if (value)
+		gpio->out[roffset] |= mask;
+	pr_debug("%s invoked, offset = 0x%08x, value = 0x%08x\n",
+		 __func__, offset, value);
+	regmap_write(map, 0x910 + roffset * sizeof(u32), gpio->out[roffset]);
+}
+
+static int mcuio_gpio_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct mcuio_gpio *gpio = container_of(chip, struct mcuio_gpio, chip);
+	struct regmap *map = gpio->map;
+	int ret, shift;
+	unsigned curr_addr;
+	u32 curr;
+
+	curr_addr = 0x510 + (offset / sizeof(u32)) * sizeof(u32);
+	pr_debug("%s: invoking regmap_read @0x%04x\n", __func__, curr_addr);
+	ret = regmap_read(map, curr_addr, &curr);
+	if (ret < 0) {
+		pr_err("%s: error reading curr config\n", __func__);
+		return ret;
+	}
+	shift = (offset % sizeof(u32)) * 8;
+
+	pr_debug("%s: curr = 0x%08x, shift = %d\n", __func__, curr, shift);
+
+	curr &= ~(0x3 << shift);
+	curr |= (0x01 << shift);
+
+	pr_debug("%s invoked, offset = 0x%08x, writing 0x%08x to 0x%08x\n",
+		 __func__, offset, curr, curr_addr);
+	return regmap_write(map, curr_addr, curr);
+}
+
+static int mcuio_gpio_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct mcuio_gpio *gpio = container_of(chip, struct mcuio_gpio, chip);
+	struct regmap *map = gpio->map;
+	int ret, shift;
+	unsigned curr_addr;
+	u32 curr;
+
+	/* Set value first */
+	mcuio_gpio_set(chip, offset, value);
+
+	/* Next configure the gpio as an output */
+	curr_addr = 0x510 + (offset / sizeof(u32)) * sizeof(u32);
+	pr_debug("%s: invoking regmap_read @0x%04x\n", __func__, curr_addr);
+	ret = regmap_read(map, curr_addr, &curr);
+	if (ret < 0) {
+		pr_err("%s: error reading curr config\n", __func__);
+		return ret;
+	}
+	shift = (offset % sizeof(u32)) * 8;
+
+	pr_debug("%s: curr = 0x%08x, shift = %d\n", __func__, curr, shift);
+
+	curr &= ~(0x3 << shift);
+	curr |= (0x02 << shift);
+
+	pr_debug("%s invoked, offset = 0x%08x, writing 0x%08x to 0x%08x\n",
+		 __func__, offset, curr, curr_addr);
+	return regmap_write(map, curr_addr, curr);
+}
+
+static int mcuio_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct mcuio_gpio *gpio = container_of(chip, struct mcuio_gpio, chip);
+	return gpio->irq_base > 0 ? gpio->irq_base + offset : -ENXIO;
+}
+
+
+static const struct regmap_config mcuio_gpio_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.max_register = 0x930,
+	.cache_type = REGCACHE_NONE,
+};
+
+static irqreturn_t mcuio_gpio_irq_handler(int irq, void *devid)
+{
+	int stat;
+	struct mcuio_gpio *gpio = devid;
+	struct regmap *map = gpio->map;
+
+	if (gpio->irq_work_pending)
+		return IRQ_HANDLED;
+
+	/* mask __before__ reading status */
+	pr_debug("%s entered\n", __func__);
+
+	pr_debug("%s: reading status[0]\n", __func__);
+	stat = regmap_read(map, 0x928, &gpio->status[0]);
+	if (stat < 0) {
+		dev_err(gpio->chip.parent, "%s: error reading gpio status[0]\n", __func__);
+		goto end;
+	}
+	pr_debug("%s: reading status[1]\n", __func__);
+	stat = regmap_read(map, 0x92c, &gpio->status[1]);
+	if (stat < 0) {
+		dev_err(gpio->chip.parent, "%s: error reading gpio status[1]\n", __func__);
+		goto end;
+	}
+
+	gpio->irq_work_pending = 1;
+	schedule_work(&gpio->irq_work);
+
+end:
+	pr_debug("leaving %s\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static void mcuio_irq_handler_bh(struct work_struct *w)
+{
+	int i;
+	struct mcuio_gpio *gpio = container_of(w, struct mcuio_gpio,
+					       irq_work);
+
+	for (i = 0; i < gpio->chip.ngpio; i++)
+		if (test_bit(i, (unsigned long *)gpio->status)) {
+			pr_debug("%s: invoking handler for irq %d\n",
+				 __func__, gpio->irq_base + i);
+			handle_nested_irq(gpio->irq_base + i);
+		}
+
+	gpio->irq_work_pending = 0;
+}
+
+static int __mcuio_gpio_set_irq_flags(struct irq_data *d, u8 flags, u8 mask)
+{
+	struct mcuio_gpio *g = irq_data_get_irq_chip_data(d);
+	unsigned gpio = d->irq - g->irq_base;
+	struct regmap *map = g->map;
+	u32 s;
+	unsigned addr = gpio + 0x710;
+	int shift = (8 * (addr % sizeof(u32))), ret;
+
+	ret = regmap_read(map, (addr / sizeof(u32)) * sizeof(u32), &s);
+	if (ret < 0) {
+		dev_err(g->chip.parent, "could not read curr evts flags\n");
+		return ret;
+	}
+	s &= ~(((u32)mask) << shift);
+	ret = regmap_write(map, (addr / sizeof(u32)) * sizeof(u32),
+			   s | ((u32)flags) << shift);
+	if (ret < 0)
+		dev_err(g->chip.parent, "could not set new evts flags\n");
+	return ret < 0 ? ret : 0;
+}
+
+static void mcuio_gpio_irq_unmask(struct irq_data *d)
+{
+	(void)__mcuio_gpio_set_irq_flags(d, 0x80, 0x80);
+}
+
+static void mcuio_gpio_irq_mask(struct irq_data *d)
+{
+	(void)__mcuio_gpio_set_irq_flags(d, 0x00, 0x80);
+}
+
+static int mcuio_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)
+{
+	u8 v = 0;
+	unsigned int t = flow_type & IRQF_TRIGGER_MASK;
+	if (t & IRQF_TRIGGER_RISING)
+		v |= 1;
+	if (t & IRQF_TRIGGER_FALLING)
+		v |= 2;
+	if (t & IRQF_TRIGGER_HIGH)
+		v |= 4;
+	if (t & IRQF_TRIGGER_LOW)
+		v |= 8;
+	return __mcuio_gpio_set_irq_flags(d, v, 0x7f);
+}
+
+static int mcuio_gpio_probe(struct mcuio_device *mdev)
+{
+	struct mcuio_gpio *g;
+	struct regmap *map;
+	unsigned int ngpios;
+	char *names, **names_ptr;
+	int i, ret;
+	struct mcuio_device *hc = to_mcuio_dev(mdev->dev.parent);
+
+	if (!hc) {
+		dev_err(&mdev->dev, "no parent for device\n");
+		return -EINVAL;
+	}
+	map = devm_regmap_init_mcuio(mdev, &mcuio_gpio_regmap_config);
+	if (IS_ERR(map)) {
+		dev_err(&mdev->dev, "cannot setup regmap for device\n");
+		return PTR_ERR(map);
+	}
+	ret = regmap_read(map, 0xc, &ngpios);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "error reading number of gpios\n");
+		return ret;
+	}
+	pr_debug("%s %d, ngpios = %d\n", __func__, __LINE__, ngpios);
+	g = devm_kzalloc(&mdev->dev, sizeof(*g), GFP_KERNEL);
+	if (!g)
+		return -ENOMEM;
+
+	g->map = map;
+	g->chip.base			= 100;
+	g->chip.can_sleep		= 1;
+	//g->chip.dev			= &mdev->dev;
+	g->chip.owner			= THIS_MODULE;
+	g->chip.get			= mcuio_gpio_get;
+	g->chip.set			= mcuio_gpio_set;
+	g->chip.direction_input		= mcuio_gpio_input;
+	g->chip.direction_output	= mcuio_gpio_output;
+	g->chip.to_irq			= mcuio_gpio_to_irq;
+	g->chip.ngpio			= ngpios;
+	g->irqchip.irq_set_type		= mcuio_gpio_irq_set_type;
+	g->irqchip.irq_mask		= mcuio_gpio_irq_mask;
+	g->irqchip.irq_unmask		= mcuio_gpio_irq_unmask;
+	INIT_WORK(&g->irq_work, mcuio_irq_handler_bh);
+	regmap_read(map, 0x910, &g->out[0]);
+	regmap_read(map, 0x914, &g->out[1]);
+	pr_debug("%s: initial state = 0x%08x-0x%08x\n", __func__, g->out[0],
+		 g->out[1]);
+	snprintf(g->label, sizeof(g->label), "mcuio-%u:%u.%u", mdev->bus,
+		 mdev->device, mdev->fn);
+
+	/*
+	 * Get 8 bytes per gpio label. Labels are actually 4 bytes long, plus
+	 * a terminator
+	 */
+	names = devm_kzalloc(&mdev->dev, 8 * g->chip.ngpio, GFP_KERNEL);
+	if (!names) {
+		dev_err(&mdev->dev, "no memory for gpio names\n");
+		return -ENOMEM;
+	}
+	names_ptr = devm_kzalloc(&mdev->dev, g->chip.ngpio * sizeof(char *),
+				 GFP_KERNEL);
+	if (!names_ptr) {
+		dev_err(&mdev->dev, "no memory for gpio names ptrs array\n");
+		return -ENOMEM;
+	}
+	for (i = 0; i < g->chip.ngpio; i++) {
+		regmap_read(map, 0x10 + i*4, (u32 *)&names[i*8]);
+		dev_dbg(&mdev->dev, "found gpio %u: %s\n",
+			 g->chip.base + i, &names[i*8]);
+		names_ptr[i] = &names[i*8];
+	}
+	g->chip.names = (const char *const *)names_ptr;
+
+	pr_debug("%s: max gpios = %d\n", __func__, ARCH_NR_GPIOS);
+	ret = gpiochip_add(&g->chip);
+	if (ret) {
+		pr_err("Error %d adding gpiochip\n", ret);
+		return ret;
+	}
+	g->irq_base = irq_alloc_descs(-1, 0, g->chip.ngpio, 0);
+	if (g->irq_base < 0) {
+		dev_err(&mdev->dev, "could not allocate irq descriptors\n");
+		return -ENOMEM;
+	}
+	for (i = 0; i < g->chip.ngpio; i++) {
+		int irq = i + g->irq_base;
+		irq_clear_status_flags(irq, IRQ_NOREQUEST);
+		irq_set_chip_data(irq, g);
+		irq_set_chip(irq, &g->irqchip);
+		irq_set_nested_thread(irq, true);
+		irq_set_noprobe(irq);
+	}
+	ret = request_threaded_irq(mdev->irq, NULL, mcuio_gpio_irq_handler,
+				   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				   "mcuio-gpio", g);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "error requesting mcuio gpio irq\n");
+		goto fail;
+	}
+
+	dev_set_drvdata(&mdev->dev, g);
+	return 0;
+
+fail:
+	irq_free_descs(g->irq_base, g->chip.ngpio);
+	return ret;
+}
+
+static int mcuio_gpio_remove(struct mcuio_device *mdev)
+{
+	struct mcuio_gpio *g = dev_get_drvdata(&mdev->dev);
+	if (!g) {
+		dev_err(&mdev->dev, "%s: no drvdata", __func__);
+		return -EINVAL;
+	}
+	free_irq(mdev->irq, g);
+	irq_free_descs(g->irq_base, g->chip.ngpio);
+	gpiochip_remove(&g->chip);
+	return 0;
+}
+
+static const struct mcuio_device_id gpio_drv_ids[] = {
+	{
+		.class = MCUIO_CLASS_GPIO,
+		.class_mask = 0xffff,
+	},
+	/* Terminator */
+	{
+		.device = MCUIO_NO_DEVICE,
+		.class = MCUIO_CLASS_UNDEFINED,
+	},
+};
+
+static struct mcuio_driver mcuio_gpio_driver = {
+	.driver = {
+		.name = "mcuio-gpio",
+	},
+	.id_table = gpio_drv_ids,
+	.probe = mcuio_gpio_probe,
+	.remove = mcuio_gpio_remove,
+};
+
+static int __init mcuio_gpio_init(void)
+{
+	return mcuio_driver_register(&mcuio_gpio_driver, THIS_MODULE);
+}
+
+static void __exit mcuio_gpio_exit(void)
+{
+	return mcuio_driver_unregister(&mcuio_gpio_driver);
+}
+
+subsys_initcall(mcuio_gpio_init);
+module_exit(mcuio_gpio_exit);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO gpio generic driver");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/i2c/busses/i2c-mcuio.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/i2c/busses/i2c-mcuio.c
@@ -0,0 +1,670 @@
+/*
+ * mcuio I2c controller driver
+ * Some code from drivers/i2c/busses/i2c-nomadik
+ * smbus xfer comes from drivers/i2c/busses/i2c-stub.c
+ */
+/* #define DEBUG 1 */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/circ_buf.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-proto.h>
+
+#define I2C_MCUIO_BUF_MAX_SIZE 0x100
+#define I2C_MCUIO_IBUF_MAX_SIZE I2C_MCUIO_BUF_MAX_SIZE
+#define I2C_MCUIO_OBUF_MAX_SIZE I2C_MCUIO_BUF_MAX_SIZE
+
+#define LOCAL_BUF_SIZE 2048
+
+/*
+ * Xfer data register (xfers are limited to 255 bytes)
+ *
+ * Byte  0   -> slave address
+ * Byte  1   -> obuf length
+ * Byte  2   -> ibuf length
+ */
+#define I2C_MCUIO_XFER_DATA	0x008
+#define I2C_REG_START		I2C_XFER_DATA
+
+/*
+ * Status register:
+ *
+ * Byte 0 -> flags
+ * Byte 1 -> ibuf count
+ * Byte 2 -> obuf space
+ */
+#define I2C_MCUIO_STATUS	0x00c
+#define	  TRANSACTION_OK	  0x1
+#define	  OBUF_LO_WM_REACHED	  0x02
+#define	  IBUF_HI_WM_REACHED	  0x04
+#define	  NAK_RECEIVED		  0x80
+#define	  INVALID_LEN		  0x81
+#define	  BUSY			  0x82
+
+#define I2C_MCUIO_CFG		0x010
+#define I2C_MCUIO_BRATE		0x014
+#define I2C_MCUIO_CMD		0x018
+#define	  START_TRANSACTION	  0x1
+#define	  INTEN			  0x2
+#define I2C_MCUIO_BUF_SIZE	0x020
+#define I2C_REG_END		(I2C_MCUIO_IBUF + I2C_MCUIO_IBUF_MAX_SIZE)
+
+#define I2C_MCUIO_OBUF		0x040
+#define I2C_MCUIO_IBUF		(I2C_MCUIO_OBUF + I2C_MCUIO_OBUF_MAX_SIZE)
+
+struct mcuio_i2c_dev {
+	struct i2c_adapter adapter;
+	struct mcuio_device *mdev;
+	struct regmap *map_dw;
+	struct regmap *map_b;
+	struct completion xfer_complete;
+	int xfer_status;
+	unsigned buf_size;
+	int olen;
+	int ilen;
+	unsigned short flags;
+	unsigned short addr;
+	int sent;
+	int received;
+	u8 buf[LOCAL_BUF_SIZE];
+};
+
+static inline u8 __flags(u32 v)
+{
+	return v & 0xff;
+}
+
+static inline u8 __space(u32 v)
+{
+	return (v >> 16) & 0xff;
+}
+
+static inline u8 __count(u32 v)
+{
+	return (v >> 8) & 0xff;
+}
+
+static inline int __get_status(struct mcuio_i2c_dev *i2cd, u32 *s)
+{
+	return regmap_read(i2cd->map_dw, I2C_MCUIO_STATUS, s);
+}
+
+static inline int __get_space(struct mcuio_i2c_dev *i2cd)
+{
+	int stat;
+	u32 s;
+
+	stat = __get_status(i2cd, &s);
+	if (stat < 0)
+		return stat;
+	return __space(s);
+}
+
+static inline int __get_count(struct mcuio_i2c_dev *i2cd)
+{
+	int stat;
+	u32 s;
+
+	stat = __get_status(i2cd, &s);
+	if (stat < 0)
+		return stat;
+	return __count(s);
+}
+
+static int ___send_obuf(struct mcuio_i2c_dev *i2cd, int space)
+{
+	int togo, l, stat;
+
+	togo = i2cd->olen - i2cd->sent;
+	/*
+	 * Make size an integer multiple of the number of data bytes in
+	 * a single wrb mcuio packet (with fill flag set).
+	 * This is to reduce the mcuio overhead (try sending as few single
+	 * byte packets as possible).
+	 */
+	if (space > 8)
+		space = (space >> 3) << 3;
+	l = min(space, togo);
+	pr_debug("%s: space = %d, togo = %d, l = %d, sent = %d\n",
+		 __func__, space, togo, l, i2cd->sent);
+	stat = regmap_raw_write(i2cd->map_b, I2C_MCUIO_OBUF,
+				&i2cd->buf[i2cd->sent], l);
+	if (stat < 0) {
+		dev_err(&i2cd->mdev->dev, "error sending output buffer\n");
+		return stat;
+	}
+	i2cd->sent += l;
+	return stat;
+}
+
+static int __send_obuf(struct mcuio_i2c_dev *i2cd)
+{
+	int space;
+
+	space = __get_space(i2cd);
+	if (space < 0) {
+		dev_err(&i2cd->mdev->dev, "error reading output space\n");
+		return space;
+	}
+	return ___send_obuf(i2cd, space);
+}
+
+static int ___get_ibuf(struct mcuio_i2c_dev *i2cd, int count)
+{
+	int togo, l, stat;
+
+	togo = i2cd->ilen - i2cd->received;
+	l = min(count, togo);
+	pr_debug("%s: count = %d, togo = %d, l = %d, received = %d\n",
+		 __func__, count, togo, l, i2cd->received);
+	stat = regmap_raw_read(i2cd->map_b, I2C_MCUIO_IBUF,
+			       &i2cd->buf[i2cd->received], l);
+	if (stat < 0) {
+		dev_err(&i2cd->mdev->dev, "error reading input buffer\n");
+		return stat;
+	}
+	i2cd->received += l;
+	return stat;
+}
+
+static int __get_ibuf(struct mcuio_i2c_dev *i2cd)
+{
+	int count;
+
+	count = __get_count(i2cd);
+	if (count < 0) {
+		dev_dbg(&i2cd->mdev->dev, "error reading input count\n");
+		return count;
+	}
+	if (!count) {
+		dev_dbg(&i2cd->mdev->dev, "nothing in input buffer\n");
+		return count;
+	}
+	return ___get_ibuf(i2cd, count);
+}
+
+static irqreturn_t mcuio_i2c_irq_handler(int irq, void *devid)
+{
+	/* Read status register and complete current transaction */
+	struct mcuio_i2c_dev *i2cd = devid;
+	u32 v;
+	u8 flags, count, space;
+	int stat;
+
+	BUG_ON(!i2cd || !i2cd->map_dw);
+	stat = __get_status(i2cd, &v);
+	if (stat < 0) {
+		dev_err(&i2cd->mdev->dev, "error reading i2c status\n");
+		/* This will make the transaction end with -EIO */
+		v = NAK_RECEIVED;
+	}
+	dev_dbg(&i2cd->mdev->dev, "%s: status = 0x%08x\n", __func__, v);
+
+	flags = __flags(v);
+	count = __count(v);
+	space = __space(v);
+
+	if (!flags) {
+		dev_err(&i2cd->mdev->dev, "spurious irq\n");
+		return IRQ_HANDLED;
+	}
+
+	if ((flags & NAK_RECEIVED) || (flags & TRANSACTION_OK)) {
+		i2cd->xfer_status = (stat < 0 || (v & NAK_RECEIVED)) ? -EIO : 0;
+		dev_dbg(&i2cd->mdev->dev, "%s: flags = 0x%04x\n", __func__,
+			i2cd->flags);
+		if ((i2cd->flags & I2C_M_RD) && !i2cd->xfer_status) {
+			dev_dbg(&i2cd->mdev->dev, "%s: reading ibuf\n",
+				__func__);
+			__get_ibuf(i2cd);
+		}
+		complete(&i2cd->xfer_complete);
+		return IRQ_HANDLED;
+	}
+	if ((flags & OBUF_LO_WM_REACHED) && space && (i2cd->olen - i2cd->sent))
+		___send_obuf(i2cd, space);
+	if ((flags & IBUF_HI_WM_REACHED) && count &&
+	    (i2cd->ilen - i2cd->received))
+		___get_ibuf(i2cd, count);
+	dev_dbg(&i2cd->mdev->dev, "%s: xfer_status = %d\n", __func__,
+		i2cd->xfer_status);
+	return IRQ_HANDLED;
+}
+
+#ifdef DEBUG
+static void __dump_message(struct device *dev, struct i2c_msg *msg)
+{
+	int i;
+	dev_dbg(dev, "i2c msg len = %u\n", msg->len);
+	printk(KERN_DEBUG);
+	for (i = 0; i < msg->len; i++) {
+		printk("0x%02x\t", msg->buf[i]);
+		if (i && !(i % 8)) {
+			printk("\n");
+			printk(KERN_DEBUG);
+		}
+	}
+	printk("\n");
+}
+#else
+static inline void __dump_message(struct device *dev, struct i2c_msg *msg)
+{
+}
+#endif
+
+static int __do_xfer(struct i2c_adapter * a)
+{
+	u32 v;
+	int ret, timeout;
+	struct mcuio_i2c_dev *i2cd = i2c_get_adapdata(a);
+
+	/* Set slave address, ilength, olength */
+	v = (((u32)i2cd->addr) << 1) | (((u32)i2cd->olen) << 8) |
+		(((u32)i2cd->ilen) << 20);
+	dev_dbg(&i2cd->mdev->dev, "setting xfer data 0x%08x\n", v);
+	ret = regmap_write(i2cd->map_dw, I2C_MCUIO_XFER_DATA, v);
+	if (ret < 0) {
+		dev_err(&i2cd->mdev->dev, "error setting xfer data\n");
+		return ret;
+	}
+
+	/* Write message to buffer */
+	/* FIXME: check whether regmap_raw_write works */
+	i2cd->received = 0;
+	i2cd->sent = 0;
+	if (i2cd->olen) {
+		ret = __send_obuf(i2cd);
+		if (ret < 0) {
+			dev_err(&i2cd->mdev->dev,
+				"error sending output buffer\n");
+			return ret;
+		}
+	}
+
+	/* Initialize xfer status and init xfer completion struct */
+	i2cd->xfer_status = -ETIMEDOUT;
+	init_completion(&i2cd->xfer_complete);
+
+	/* Issue xmit command and enable interrupt */
+	v = START_TRANSACTION | INTEN;
+	dev_dbg(&i2cd->mdev->dev, "starting transaction\n");
+	ret = regmap_write(i2cd->map_dw, I2C_MCUIO_CMD, v);
+	if (ret < 0) {
+		dev_err(&i2cd->mdev->dev, "error starting transaction\n");
+		return ret;
+	}
+
+	/* Wait for transfer complete */
+	timeout = wait_for_completion_timeout(&i2cd->xfer_complete,
+					      a->timeout);
+	if (timeout < 0) {
+		dev_err(&i2cd->mdev->dev, "error %d on slave xfer\n", timeout);
+		ret = timeout;
+	}
+	if (!timeout)
+		/*
+		 * In case of timeout, the initial value of i2cd->xfer_status
+		 * will be returned
+		 */
+		dev_err(&i2cd->mdev->dev, "timeout on slave xfer\n");
+	else
+		dev_dbg(&i2cd->mdev->dev, "transaction done\n");
+	return ret < 0 ? ret : i2cd->xfer_status;
+}
+
+static int mcuio_simple_i2c_xfer_one(struct i2c_adapter *a,
+				     struct i2c_msg *msg)
+{
+	struct mcuio_i2c_dev *i2cd = i2c_get_adapdata(a);
+	int ret;
+
+	if (!i2cd) {
+		WARN_ON(1);
+		return -ENODEV;
+	}
+
+	if (msg->len > LOCAL_BUF_SIZE) {
+		dev_dbg(&i2cd->mdev->dev, "i2c message is too long\n");
+		return -EINVAL;
+	}
+
+	__dump_message(&i2cd->mdev->dev, msg);
+
+	i2cd->olen = i2cd->ilen = 0;
+	i2cd->flags = msg->flags;
+	i2cd->addr = msg->addr;
+
+	if (msg->flags & I2C_M_RD)
+		i2cd->ilen = msg->len;
+	else
+		i2cd->olen = msg->len;
+
+	if (i2cd->olen)
+		memcpy(i2cd->buf, msg->buf, i2cd->olen);
+
+	ret = __do_xfer(a);
+	if (ret < 0 || !i2cd->ilen)
+		return ret;
+
+	memcpy(msg->buf, i2cd->buf, i2cd->ilen);
+	return ret;
+}
+
+static int mcuio_simple_i2c_xfer(struct i2c_adapter *a,
+				 struct i2c_msg msgs[], int num_msgs)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < num_msgs && !ret; i++)
+		ret = mcuio_simple_i2c_xfer_one(a, &msgs[i]);
+	return ret < 0 ? ret : num_msgs;
+}
+
+/* Return negative errno on error. */
+static s32 mcuio_simple_smbus_xfer(struct i2c_adapter * adap, u16 addr,
+				   unsigned short flags, char read_write,
+				   u8 command, int size,
+				   union i2c_smbus_data * data)
+{
+	struct mcuio_i2c_dev *i2cd = i2c_get_adapdata(adap);
+	s32 ret;
+	u32 ilen = 0, olen = 0;
+	int len;
+
+	if (!i2cd) {
+		WARN_ON(1);
+		return -ENODEV;
+	}
+
+	switch (size) {
+
+	case I2C_SMBUS_QUICK:
+		dev_dbg(&adap->dev, "smbus quick - addr 0x%02x\n", addr);
+		ret = 0;
+		break;
+
+	case I2C_SMBUS_BYTE:
+		if (read_write == I2C_SMBUS_WRITE) {
+			dev_dbg(&adap->dev, "smbus byte - wr addr 0x%02x, "
+					"write 0x%02x.\n",
+					addr, command);
+			olen = 1;
+			i2cd->buf[0] = command;
+		} else {
+			dev_dbg(&adap->dev, "smbus byte - rd addr 0x%02x\n",
+				addr);
+			ilen = 1;
+		}
+		ret = 0;
+		break;
+
+	case I2C_SMBUS_BYTE_DATA:
+		if (read_write == I2C_SMBUS_WRITE) {
+			olen = 2;
+			i2cd->buf[0] = command;
+			i2cd->buf[1] = data->byte;
+			dev_dbg(&adap->dev, "smbus byte data - addr 0x%02x, "
+					"write 0x%02x at 0x%02x.\n",
+					addr, data->byte, command);
+		} else {
+			olen = 1;
+			ilen = 1;
+			i2cd->buf[0] = command;
+			dev_dbg(&adap->dev, "smbus byte data - addr 0x%02x, "
+					"read at 0x%02x.\n",
+					addr, command);
+		}
+		ret = 0;
+		break;
+
+	case I2C_SMBUS_WORD_DATA:
+		if (read_write == I2C_SMBUS_WRITE) {
+			olen = 3;
+			i2cd->buf[0] = command;
+			i2cd->buf[1] = data->word & (u16)0x00ff;
+			i2cd->buf[2] = data->word >> 8;
+			dev_dbg(&adap->dev, "smbus word data - addr 0x%02x, "
+					"write 0x%04x at 0x%02x.\n",
+					addr, data->word, command);
+		} else {
+			i2cd->buf[0] = command;
+			olen = 1;
+			i2cd->buf[0] = command;
+			ilen = 2;
+			dev_dbg(&adap->dev, "smbus word data - addr 0x%02x, "
+					"read at 0x%02x.\n",
+					addr, command);
+		}
+
+		ret = 0;
+		break;
+
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		len = data->block[0];
+		/* smbus limit */
+		if (len < 0 || len > 32)
+			return -EINVAL;
+		i2cd->buf[0] = command;
+		if (read_write == I2C_SMBUS_WRITE) {
+			olen = 1 + len;
+			memcpy(&i2cd->buf[1], &data->block[1], len);
+		} else {
+			olen = 1;
+			ilen = len;
+		}
+		ret = 0;
+		break;
+	case I2C_SMBUS_BLOCK_DATA:
+		if (read_write == I2C_SMBUS_WRITE) {
+			len = data->block[0];
+			/* smbus limit */
+			if (len < 0 || len > 32)
+				return -EINVAL;
+			/*
+			 * FIXME: CHECK mcuio DEVICE BUFFER SIZE, disable this
+			 * if bufsize < 32
+			 */
+			olen = 1 + len;
+			i2cd->buf[0] = command;
+			memcpy(&i2cd->buf[1], &data->block[1], len);
+			dev_dbg(&adap->dev, "i2c block data - addr 0x%02x, "
+					"write %d bytes at 0x%02x.\n",
+					addr, len, command);
+		} else {
+			olen = 1;
+			/* The device tells how long the block shall be */
+			ilen = -1;
+			i2cd->buf[0] = command;
+			dev_dbg(&adap->dev, "i2c block data - addr 0x%02x, "
+					"read  ? bytes at 0x%02x.\n",
+					addr, command);
+		}
+
+		ret = 0;
+		break;
+
+	default:
+		dev_dbg(&adap->dev, "Unsupported I2C/SMBus command 0x%08x\n",
+			size);
+		ret = -EOPNOTSUPP;
+		break;
+	} /* switch (size) */
+
+	if (ret < 0)
+		return ret;
+
+	i2cd->olen = olen;
+	i2cd->ilen = ilen;
+	i2cd->flags = read_write == I2C_SMBUS_READ ? I2C_M_RD : 0;
+	i2cd->addr = addr;
+
+	ret = __do_xfer(adap);
+
+	if (ret < 0 || read_write == I2C_SMBUS_WRITE)
+		return ret;
+
+	switch (size) {
+	case I2C_SMBUS_WORD_DATA:
+		data->word = (i2cd->buf[1] << 8) | (i2cd->buf[0]);
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		data->block[0] = i2cd->ilen;
+		memcpy(&data->block[1], i2cd->buf, i2cd->ilen);
+		break;
+	default:
+		memcpy(&data->byte, i2cd->buf, i2cd->ilen);
+	}
+	return ret;
+}
+
+
+static unsigned int mcuio_simple_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_BLOCK_DATA;
+}
+
+static const struct i2c_algorithm mcuio_simple_i2c_algo = {
+	.master_xfer	= mcuio_simple_i2c_xfer,
+	.smbus_xfer	= mcuio_simple_smbus_xfer,
+	.functionality	= mcuio_simple_i2c_functionality
+};
+
+static const struct regmap_config mcuio_i2c_regmap_config_dw = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.max_register = 0x240,
+	.cache_type = REGCACHE_NONE,
+	.name = "mcuio-i2c-dw",
+};
+
+static const struct regmap_config mcuio_i2c_regmap_config_b = {
+	.reg_bits = 32,
+	.val_bits = 8,
+	.max_register = 0x240,
+	.cache_type = REGCACHE_NONE,
+	.name = "mcuio=i2c-b",
+};
+
+static int mcuio_simple_i2c_probe(struct mcuio_device *mdev)
+{
+	int ret;
+	struct mcuio_i2c_dev *i2cd;
+	struct i2c_adapter *a;
+	u32 v;
+
+	i2cd = devm_kzalloc(&mdev->dev, sizeof(*i2cd), GFP_KERNEL);
+	if (!i2cd)
+		return -ENOMEM;
+	i2cd->mdev = mdev;
+	i2cd->map_dw = devm_regmap_init_mcuio(mdev,
+					      &mcuio_i2c_regmap_config_dw);
+	if (IS_ERR(i2cd->map_dw)) {
+		dev_err(&mdev->dev, "cannot setup regmap (dw) for device\n");
+		return PTR_ERR(i2cd->map_dw);
+	}
+	i2cd->map_b = devm_regmap_init_mcuio(mdev,
+					     &mcuio_i2c_regmap_config_b);
+	if (IS_ERR(i2cd->map_b)) {
+		dev_err(&mdev->dev, "cannot setup regmap (b) for device\n");
+		return PTR_ERR(i2cd->map_b);
+	}
+
+	ret = regmap_read(i2cd->map_dw, I2C_MCUIO_BUF_SIZE, &v);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "error reading mcu buffer size\n");
+		return ret;
+	}
+	i2cd->buf_size = v;
+
+	a = &i2cd->adapter;
+
+	a->dev.parent	= &mdev->dev;
+	a->owner	= THIS_MODULE;
+	a->class	= I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	a->algo		= &mcuio_simple_i2c_algo;
+	/* FIXME: read timeout from mcu ? */
+	a->timeout	= msecs_to_jiffies(20000);
+	snprintf(a->name, sizeof(a->name),
+		 "Mcuio I2C %s", dev_name(&mdev->dev));
+
+	ret = request_threaded_irq(mdev->irq, NULL, mcuio_i2c_irq_handler,
+				   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				   "mcuio-i2c", i2cd);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "failed requesting irq\n");
+		return ret;
+	}
+
+	i2c_set_adapdata(a, i2cd);
+
+	ret = i2c_add_adapter(a);
+	if (ret) {
+		dev_err(&mdev->dev, "failed to add adapter\n");
+		free_irq(mdev->irq, i2cd);
+		return ret;
+	}
+	dev_set_drvdata(&mdev->dev, i2cd);
+	return ret;
+}
+
+static int mcuio_simple_i2c_remove(struct mcuio_device *mdev)
+{
+	struct mcuio_i2c_dev *i2cd = dev_get_drvdata(&mdev->dev);
+	i2c_del_adapter(&i2cd->adapter);
+	free_irq(mdev->irq, i2cd);
+	return 0;
+}
+
+static const struct mcuio_device_id mcuio_simple_i2c_drv_ids[] = {
+	{
+		.class = MCUIO_CLASS_I2C_CONTROLLER,
+		.class_mask = 0xffff,
+	},
+	/* Terminator */
+	{
+		.device = MCUIO_NO_DEVICE,
+		.class = MCUIO_CLASS_UNDEFINED,
+	},
+};
+
+
+static struct mcuio_driver mcuio_simple_i2c_driver = {
+	.driver = {
+		.name = "mcuio-simple-i2c",
+	},
+	.id_table = mcuio_simple_i2c_drv_ids,
+	.probe = mcuio_simple_i2c_probe,
+	.remove = mcuio_simple_i2c_remove,
+};
+
+static int __init mcuio_simple_i2c_init(void)
+{
+	return mcuio_driver_register(&mcuio_simple_i2c_driver, THIS_MODULE);
+}
+
+static void __exit mcuio_simple_i2c_exit(void)
+{
+	return mcuio_driver_unregister(&mcuio_simple_i2c_driver);
+}
+
+subsys_initcall(mcuio_simple_i2c_init);
+module_exit(mcuio_simple_i2c_exit);
+
+MODULE_AUTHOR("Davide Ciminaghi");
+MODULE_DESCRIPTION("MCUIO simple i2c controller driver");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/pwm/pwm-mcuio.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/pwm/pwm-mcuio.c
@@ -0,0 +1,316 @@
+/*
+ * Copyright 2014 Dog Hunter SA
+ * Author: Aurelio Colosimo <aurelio@aureliocolosimo.it>
+ *
+ * GNU GPLv2 or later
+ */
+
+/* mcuio driver for PWM outputs */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-proto.h>
+
+#define CAP_RES(x)     (x & 0x00ffffff)
+#define CAP_CH_PER(x)  ((x >> 24) & 0x1)
+#define CAP_CH_DC(x)   ((x >> 25) & 0x1)
+
+static const struct regmap_config mcuio_pwm_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.cache_type = REGCACHE_NONE,
+};
+
+struct mcuio_pwm_data {
+	struct pwm_chip chip;
+	struct regmap *map;
+	u32 *capab;
+};
+
+static inline struct mcuio_pwm_data *to_mcuio_pwm_data(struct pwm_chip *chip)
+{
+	return container_of(chip, struct mcuio_pwm_data, chip);
+}
+
+static inline int pwm_idx(struct pwm_device *pwm)
+{
+	return pwm - pwm->chip->pwms;
+}
+
+static int mcuio_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			    int duty_ns, int period_ns)
+{
+	struct mcuio_pwm_data *data = to_mcuio_pwm_data(chip);
+	int idx = pwm_idx(pwm);
+	uint32_t duty_ticks;
+
+	if (!CAP_CH_PER(data->capab[idx]))
+		goto set_duty;
+
+	if (regmap_write(data->map, 0x040 * (idx + 1) + 0x10,
+		period_ns / period_ns))	//mimmo pwm->resolution))
+		return -EIO;
+
+set_duty:
+	if (!CAP_CH_DC(data->capab[idx]))
+		goto done;
+
+	duty_ticks = duty_ns / period_ns;	//mimmo pwm->resolution;
+
+	if (regmap_write(data->map, 0x040 * (idx + 1) + 0x14, duty_ticks))
+		return -EIO;
+
+done:
+	return 0;
+}
+
+static int mcuio_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,
+				  enum pwm_polarity polarity)
+{
+	struct mcuio_pwm_data *data = to_mcuio_pwm_data(chip);
+	int idx = pwm_idx(pwm);
+	u32 st;
+	u32 addr;
+
+	addr = 0x040 * (idx + 1) + 0x0c;
+
+	if (regmap_read(data->map, addr, &st))
+		return -EIO;
+
+	if (polarity == PWM_POLARITY_NORMAL)
+		st &= ~(1 << 1);
+	else
+		st |= (1 << 1);
+
+	if (regmap_write(data->map, addr, st))
+		return -EIO;
+
+	return 0;
+}
+
+static int mcuio_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct mcuio_pwm_data *data = to_mcuio_pwm_data(chip);
+	int idx = pwm_idx(pwm);
+	u32 st;
+	u32 addr;
+
+	addr = 0x040 * (idx + 1) + 0x0c;
+
+	if (regmap_read(data->map, addr, &st))
+		return -EIO;
+
+	if (regmap_write(data->map, addr, st | 0x1))
+		return -EIO;
+
+	return 0;
+}
+
+static void mcuio_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct mcuio_pwm_data *data = to_mcuio_pwm_data(chip);
+	int idx = pwm_idx(pwm);
+	u32 st = 0;
+	u32 addr;
+
+	addr = 0x040 * (idx + 1) + 0x0c;
+
+	if (regmap_read(data->map, addr, &st))
+		dev_warn(chip->dev, "could not read current status while "
+			"disabling pwm %d\n", idx);
+
+	if (regmap_write(data->map, addr, st & ~0x1))
+		dev_warn(chip->dev, "I/O error while disabling pwm %d\n",
+			 idx);
+}
+/*
+static int mcuio_pwm_update_period(struct pwm_chip *chip,
+				    struct pwm_device *pwm)
+{
+	struct mcuio_pwm_data *data = to_mcuio_pwm_data(chip);
+	int idx = pwm_idx(pwm);
+	u32 val;
+	if (regmap_read(data->map, 0x040 * (idx + 1) + 0x10, &val))
+		return -EIO;
+
+	pwm->period = val * period_ns;	//mimmo pwm->resolution;
+	return 0;
+}
+
+static int mcuio_pwm_update_duty(struct pwm_chip *chip,
+				 struct pwm_device *pwm)
+{
+	struct mcuio_pwm_data *data = to_mcuio_pwm_data(chip);
+	int idx = pwm_idx(pwm);
+	u32 val;
+	if (regmap_read(data->map, 0x040 * (idx + 1) + 0x14, &val))
+		return -EIO;
+
+	pwm->duty_cycle = val * period_ns;	//mimmo pwm->resolution;
+	return 0;
+}
+*/
+
+static const struct pwm_ops mcuio_pwm_ops = {
+	.config = mcuio_pwm_config,
+	.set_polarity = mcuio_pwm_set_polarity,
+	.enable = mcuio_pwm_enable,
+	.disable = mcuio_pwm_disable,
+	//.update_period = mcuio_pwm_update_period,
+	//.update_duty = mcuio_pwm_update_duty,
+	.owner = THIS_MODULE,
+};
+
+static int mcuio_pwm_probe(struct mcuio_device *mdev)
+{
+	int ret;
+	struct mcuio_pwm_data *data = NULL;
+	struct regmap *map = NULL;
+	struct mcuio_device *hc = to_mcuio_dev(mdev->dev.parent);
+	char *names;
+	int i;
+	u32 max_ticks;
+
+	if (!hc) {
+		dev_err(&mdev->dev, "no parent for device\n");
+		return -EINVAL;
+	}
+
+	map = devm_regmap_init_mcuio(mdev, &mcuio_pwm_regmap_config);
+
+	if (IS_ERR(map)) {
+		dev_err(&mdev->dev, "cannot setup regmap for device\n");
+		return PTR_ERR(map);
+	}
+
+	data = devm_kzalloc(&mdev->dev, sizeof(*data), GFP_KERNEL);
+
+	if (!data) {
+		dev_err(&mdev->dev, "error creating pwm_data\n");
+		ret = -ENOMEM;
+		goto fail1;
+	}
+
+	data->map = map;
+
+	pr_info("mcuio pwm is %u:%u:%u\n",
+		 mdev->bus, mdev->device, mdev->fn);
+
+	data->chip.dev = &mdev->dev;
+	data->chip.ops = &mcuio_pwm_ops;
+	data->chip.base = -1;
+
+	if (regmap_read(data->map, 0x08, &data->chip.npwm) < 0) {
+		ret = -EIO;
+		goto fail1;
+	}
+
+	dev_info(&mdev->dev, "%d pwm outputs detected\n", data->chip.npwm);
+
+	dev_set_drvdata(&mdev->dev, data);
+
+	ret = pwmchip_add(&data->chip);
+	if (ret < 0) {
+		dev_err(&mdev->dev, "failed to add PWM chip, error %d\n", ret);
+		return ret;
+	}
+
+	names = devm_kzalloc(&mdev->dev, 8 * data->chip.npwm, GFP_KERNEL);
+
+	if (!names) {
+		ret = -ENOMEM;
+		goto fail1;
+	}
+
+	data->capab = devm_kzalloc(&mdev->dev,
+		sizeof(*data->capab) * data->chip.npwm,
+		GFP_KERNEL);
+
+	if (!data->capab) {
+		ret = -ENOMEM;
+		goto fail1;
+	}
+
+	for (i = 0; i < data->chip.npwm; i++) {
+
+		regmap_read(data->map, 0x040 * (i + 1), (u32*)&names[i * 8]);
+		dev_dbg(&mdev->dev, "found pwm %d: %s\n", i, &names[i * 8]);
+
+		//data->chip.pwms[i].name = &names[i * 8];
+
+		regmap_read(data->map, 0x040 * (i + 1) + 0x04,
+			    &data->capab[i]);
+
+		//data->chip.pwms[i].resolution = CAP_RES(data->capab[i]);
+
+		regmap_read(data->map, 0x040 * (i + 1) + 0x08,
+			    &max_ticks);
+
+		//data->chip.pwms[i].max = max_ticks * data->chip.pwms[i].resolution;
+	}
+	return ret;
+
+fail1:
+	return ret;
+}
+
+static int mcuio_pwm_remove(struct mcuio_device *mdev)
+{
+	struct mcuio_pwm_data *data = dev_get_drvdata(&mdev->dev);
+
+	pr_debug("removing mcuio pwm %u:%u:%u\n",
+		 mdev->bus, mdev->device, mdev->fn);
+	BUG_ON(!data);
+
+	return pwmchip_remove(&data->chip);
+}
+
+static const struct mcuio_device_id pwm_drv_ids[] = {
+	{
+		.class = MCUIO_CLASS_PWM,
+		.class_mask = 0xffff,
+	},
+	/* Terminator */
+	{
+		.device = MCUIO_NO_DEVICE,
+		.class = MCUIO_CLASS_UNDEFINED,
+	},
+};
+
+static struct mcuio_driver mcuio_pwm_driver = {
+	.driver = {
+		.name = "mcuio-pwm",
+	},
+	.id_table = pwm_drv_ids,
+	.probe = mcuio_pwm_probe,
+	.remove = mcuio_pwm_remove,
+};
+
+static int __init mcuio_pwm_init(void)
+{
+	return mcuio_driver_register(&mcuio_pwm_driver, THIS_MODULE);
+}
+
+static void __exit mcuio_pwm_exit(void)
+{
+	mcuio_driver_unregister(&mcuio_pwm_driver);
+}
+
+subsys_initcall(mcuio_pwm_init);
+module_exit(mcuio_pwm_exit);
+
+MODULE_AUTHOR("Aurelio Colosimo");
+MODULE_DESCRIPTION("MCUIO driver for PWM");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/include/linux/regmap.h
===================================================================
--- linux-4.9.87.orig/include/linux/regmap.h
+++ linux-4.9.87/include/linux/regmap.h
@@ -30,6 +30,7 @@ struct regmap;
 struct regmap_range_cfg;
 struct regmap_field;
 struct snd_ac97;
+struct mcuio_device;
 
 /* An enum of all the supported cache types */
 enum regcache_type {
@@ -490,6 +491,10 @@ struct regmap *__devm_regmap_init_ac97(s
 				       const struct regmap_config *config,
 				       struct lock_class_key *lock_key,
 				       const char *lock_name);
+struct regmap *regmap_init_mcuio(struct mcuio_device *mdev,
+                                 const struct regmap_config *config);
+struct regmap *devm_regmap_init_mcuio(struct mcuio_device *mdev,
+                                      const struct regmap_config *config);
 
 /*
  * Wrapper for regmap_init macros to include a unique lockdep key and name
Index: linux-4.9.87/drivers/base/regmap/Kconfig
===================================================================
--- linux-4.9.87.orig/drivers/base/regmap/Kconfig
+++ linux-4.9.87/drivers/base/regmap/Kconfig
@@ -37,3 +37,6 @@ config REGMAP_MMIO
 config REGMAP_IRQ
 	select REGMAP
 	bool
+
+config REGMAP_MCUIO
+        tristate
\ No newline at end of file
Index: linux-4.9.87/drivers/base/regmap/Makefile
===================================================================
--- linux-4.9.87.orig/drivers/base/regmap/Makefile
+++ linux-4.9.87/drivers/base/regmap/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_REGMAP_SPI) += regmap-spi.o
 obj-$(CONFIG_REGMAP_SPMI) += regmap-spmi.o
 obj-$(CONFIG_REGMAP_MMIO) += regmap-mmio.o
 obj-$(CONFIG_REGMAP_IRQ) += regmap-irq.o
+obj-$(CONFIG_REGMAP_MCUIO) += regmap-mcuio-remote.o
\ No newline at end of file
Index: linux-4.9.87/drivers/i2c/busses/Kconfig
===================================================================
--- linux-4.9.87.orig/drivers/i2c/busses/Kconfig
+++ linux-4.9.87/drivers/i2c/busses/Kconfig
@@ -1224,4 +1224,10 @@ config I2C_OPAL
 	  This driver can also be built as a module. If so, the module will be
 	  called as i2c-opal.
 
+config I2C_MCUIO
+        tristate "MCUIO I2C driver"
+        depends on MCUIO
+        help
+          Add support for mcuio i2c driver"
+          
 endmenu
Index: linux-4.9.87/drivers/i2c/busses/Makefile
===================================================================
--- linux-4.9.87.orig/drivers/i2c/busses/Makefile
+++ linux-4.9.87/drivers/i2c/busses/Makefile
@@ -123,5 +123,6 @@ obj-$(CONFIG_I2C_PCA_ISA)	+= i2c-pca-isa
 obj-$(CONFIG_I2C_SIBYTE)	+= i2c-sibyte.o
 obj-$(CONFIG_I2C_XGENE_SLIMPRO) += i2c-xgene-slimpro.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
+obj-$(CONFIG_I2C_MCUIO)     += i2c-mcuio.o
 
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
Index: linux-4.9.87/drivers/gpio/Kconfig
===================================================================
--- linux-4.9.87.orig/drivers/gpio/Kconfig
+++ linux-4.9.87/drivers/gpio/Kconfig
@@ -263,6 +263,12 @@ config GPIO_MB86S7X
 	help
 	  Say yes here to support the GPIO controller in Fujitsu MB86S70 SoCs.
 
+config GPIO_MCUIO
+        tristate "MCUIO gpio driver"
+        depends on MCUIO
+        help
+          This enables an MCUIO driver for MCUIO GPIO devices
+
 config GPIO_MENZ127
 	tristate "MEN 16Z127 GPIO support"
 	depends on MCB
@@ -543,6 +549,7 @@ config GPIO_LOONGSON1
 	help
 	  Say Y or M here to support GPIO on Loongson1 SoCs.
 
+
 endmenu
 
 menu "Port-mapped I/O GPIO drivers"
Index: linux-4.9.87/drivers/gpio/Makefile
===================================================================
--- linux-4.9.87.orig/drivers/gpio/Makefile
+++ linux-4.9.87/drivers/gpio/Makefile
@@ -143,3 +143,4 @@ obj-$(CONFIG_GPIO_ZYNQ)		+= gpio-zynq.o
 obj-$(CONFIG_GPIO_ZX)		+= gpio-zx.o
 obj-$(CONFIG_GPIO_LOONGSON1)	+= gpio-loongson1.o
 obj-$(CONFIG_GPIO_MT7621)	+= gpio-mt7621.o
+obj-$(CONFIG_GPIO_MCUIO)    += gpio-mcuio.o
Index: linux-4.9.87/drivers/pwm/Kconfig
===================================================================
--- linux-4.9.87.orig/drivers/pwm/Kconfig
+++ linux-4.9.87/drivers/pwm/Kconfig
@@ -262,6 +262,13 @@ config PWM_LPSS_PLATFORM
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-lpss-platform.
 
+config PWM_MCUIO
+        tristate "mcuio PWM driver"
+        depends on MCUIO
+        default y
+        help
+          Adds a driver mcuio PWM outputs (experimental)
+
 config PWM_MESON
 	tristate "Amlogic Meson PWM driver"
 	depends on ARCH_MESON
Index: linux-4.9.87/drivers/pwm/Makefile
===================================================================
--- linux-4.9.87.orig/drivers/pwm/Makefile
+++ linux-4.9.87/drivers/pwm/Makefile
@@ -47,3 +47,4 @@ obj-$(CONFIG_PWM_TIPWMSS)	+= pwm-tipwmss
 obj-$(CONFIG_PWM_TWL)		+= pwm-twl.o
 obj-$(CONFIG_PWM_TWL_LED)	+= pwm-twl-led.o
 obj-$(CONFIG_PWM_VT8500)	+= pwm-vt8500.o
+obj-$(CONFIG_PWM_MCUIO) 	+= pwm-mcuio.o
\ No newline at end of file
Index: linux-4.9.87/drivers/iio/adc/mcuio_adc.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/iio/adc/mcuio_adc.c
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2014 Dog Hunter SA
+ * Author: Aurelio Colosimo <aurelio@aureliocolosimo.it>
+ *
+ * GNU GPLv2 or later
+ */
+
+/* MCUIO IIO driver for ADC inputs */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/iio/iio.h>
+#include <linux/regmap.h>
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-proto.h>
+
+#define MCUIO_ADC_FLAG_SIGNED	(1 << 0)
+
+struct mcuio_adc {
+	struct regmap *map;
+	u32 vres_uv;
+};
+
+static const struct regmap_config mcuio_adc_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int mcuio_adc_read_raw(struct iio_dev *idev,
+			    struct iio_chan_spec const *ch, int *val,
+			    int *shift, long mask)
+{
+	struct mcuio_adc *adc = iio_priv(idev);
+	int ret = -EINVAL;
+	u32 _val = 0;
+	u32 addr;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		addr = 0x040 * (ch->address + 1) + 0x0c;
+		break;
+
+	case IIO_CHAN_INFO_SCALE:
+		addr = 0x040 * (ch->address + 1) + 0x08;
+		break;
+
+	default:
+		goto out;
+	}
+
+	ret = regmap_read(adc->map, addr, &_val);
+
+	if (ret < 0) {
+		dev_err(&idev->dev,
+			"failed to read mcuio addr %03x\n", addr);
+		goto out;
+	}
+
+	*val = _val;
+	ret = IIO_VAL_INT;
+
+out:
+	return ret;
+}
+
+static const struct iio_info mcuio_adc_info = {
+	.read_raw = mcuio_adc_read_raw,
+	.driver_module = THIS_MODULE,
+};
+
+
+ssize_t mcuio_adc_enable_read(struct iio_dev *idev, uintptr_t private,
+			struct iio_chan_spec const *channel, char *buf)
+{
+	u32 en = 0;
+	struct mcuio_adc *adc = iio_priv(idev);
+	regmap_read(adc->map, 0x14, &en);
+	return snprintf(buf, PAGE_SIZE, "%d\n", en & 0x1 ? 1 : 0);
+}
+
+ssize_t mcuio_adc_enable_write(struct iio_dev *idev, uintptr_t private,
+			 struct iio_chan_spec const *channel, const char *buf,
+			 size_t len)
+{
+	uint32_t _en, en_new;
+	struct mcuio_adc *adc = iio_priv(idev);
+	regmap_read(adc->map, 0x14, &_en);
+	en_new = (buf[0] - '0') & 0x1;
+	regmap_write(adc->map, 0x14, (_en & ~0x1) | en_new);
+	return len;
+}
+
+static struct iio_chan_spec_ext_info iio_chan_spec_enable = {
+	.name = "enable",
+	.shared = IIO_SHARED_BY_ALL,
+	.read = mcuio_adc_enable_read,
+	.write = mcuio_adc_enable_write,
+};
+
+static int mcuio_adc_probe(struct mcuio_device *mdev)
+{
+	struct iio_dev *idev;
+	struct mcuio_adc *adc;
+	int ret = 0;
+	u32 flags;
+	struct iio_chan_spec *ch;
+	int i;
+	char *lbls;
+
+	idev = devm_iio_device_alloc(&mdev->dev, sizeof(*adc));
+	if (!idev)
+		return -ENOMEM;
+
+	dev_set_drvdata(&mdev->dev, idev);
+
+	adc = iio_priv(idev);
+
+	adc->map = devm_regmap_init_mcuio(mdev, &mcuio_adc_regmap_config);
+
+	if (IS_ERR(adc->map)) {
+		dev_err(&mdev->dev, "cannot setup regmap for device\n");
+		return PTR_ERR(adc->map);
+	}
+
+	idev->dev.parent = &mdev->dev;
+	idev->name = "mcuio-adc";
+	idev->modes = INDIO_DIRECT_MODE;
+	idev->info = &mcuio_adc_info;
+
+	pr_info("mcuio adc is %u:%u:%u\n",
+		 mdev->bus, mdev->device, mdev->fn);
+
+	/* Read nchannels */
+	ret = regmap_read(adc->map, 0x008, &idev->num_channels);
+	if (ret < 0)
+		return ret;
+	dev_info(&mdev->dev, "%d input channels detected\n",
+		 idev->num_channels);
+
+	/* Allocate mem for channels info */
+	ch = devm_kzalloc(&mdev->dev,
+			idev->num_channels * sizeof(struct iio_chan_spec),
+			GFP_KERNEL);
+
+	if (!ch)
+		return -ENOMEM;
+
+	/* Allocate mem for labels */
+	lbls = devm_kzalloc(&mdev->dev,
+			idev->num_channels * 8, GFP_KERNEL);
+	if (!lbls)
+		return -ENOMEM;
+
+	/* Initialize channels info */
+	for (i = 0; i < idev->num_channels; i++) {
+		ch[i].type = IIO_VOLTAGE;
+		ch[i].indexed = 1;
+		ch[i].channel = ch[i].address = i;
+		ch[i].info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE);
+
+		/* read flags */
+		regmap_read(adc->map, 0x040 * (i + 1) + 0x04, &flags);
+		ch[i].differential = flags & MCUIO_ADC_FLAG_SIGNED ? 1 : 0;
+		ch[i].indexed = ch[i].differential ? 1 : 0;
+
+		if (i == 0)
+			ch[i].ext_info = &iio_chan_spec_enable;
+
+		/* read label */
+		regmap_read(adc->map, 0x040 * (i + 1), (u32*)&lbls[i * 8]);
+		ch[i].extend_name = &lbls[i * 8];
+		dev_dbg(&mdev->dev, "found adc %u: %s\n", i, &lbls[i * 8]);
+	}
+
+	idev->channels = ch;
+
+	ret = iio_device_register(idev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mcuio_adc_remove(struct mcuio_device *mdev)
+{
+	struct iio_dev *idev = dev_get_drvdata(&mdev->dev);
+	iio_device_unregister(idev);
+	return 0;
+}
+
+static const struct mcuio_device_id mcuio_adc_drv_ids[] = {
+	{
+		.class = MCUIO_CLASS_ADC,
+		.class_mask = 0xffff,
+	},
+	/* Terminator */
+	{
+		.device = MCUIO_NO_DEVICE,
+		.class = MCUIO_CLASS_UNDEFINED,
+	},
+};
+
+static struct mcuio_driver mcuio_adc_driver = {
+	.driver = {
+		.name = "mcuio-adc",
+	},
+	.id_table = mcuio_adc_drv_ids,
+	.probe = mcuio_adc_probe,
+	.remove = mcuio_adc_remove,
+};
+
+static int __init mcuio_adc_init(void)
+{
+	return mcuio_driver_register(&mcuio_adc_driver, THIS_MODULE);
+}
+
+static void __exit mcuio_adc_exit(void)
+{
+	mcuio_driver_unregister(&mcuio_adc_driver);
+}
+
+subsys_initcall(mcuio_adc_init);
+module_exit(mcuio_adc_exit);
+
+MODULE_AUTHOR("Aurelio Colosimo <aurelio@aureliocolosimo.it>");
+MODULE_DESCRIPTION("MCUIO adc driver");
+MODULE_LICENSE("GPL v2");
Index: linux-4.9.87/drivers/iio/adc/Kconfig
===================================================================
--- linux-4.9.87.orig/drivers/iio/adc/Kconfig
+++ linux-4.9.87/drivers/iio/adc/Kconfig
@@ -326,6 +326,13 @@ config MCP3422
 	  This driver can also be built as a module. If so, the module will be
 	  called mcp3422.
 
+config MCUIO_ADC
+        tristate "mcuio ADC driver"
+        depends on MCUIO
+        default y
+        help
+          Adds a driver mcuio ADC inputs (experimental)
+          
 config MEDIATEK_MT6577_AUXADC
         tristate "MediaTek AUXADC driver"
         depends on ARCH_MEDIATEK || COMPILE_TEST
Index: linux-4.9.87/drivers/iio/adc/Makefile
===================================================================
--- linux-4.9.87.orig/drivers/iio/adc/Makefile
+++ linux-4.9.87/drivers/iio/adc/Makefile
@@ -32,6 +32,7 @@ obj-$(CONFIG_MAX1027) += max1027.o
 obj-$(CONFIG_MAX1363) += max1363.o
 obj-$(CONFIG_MCP320X) += mcp320x.o
 obj-$(CONFIG_MCP3422) += mcp3422.o
+obj-$(CONFIG_MCUIO_ADC) += mcuio_adc.o
 obj-$(CONFIG_MEDIATEK_MT6577_AUXADC) += mt6577_auxadc.o
 obj-$(CONFIG_MEN_Z188_ADC) += men_z188_adc.o
 obj-$(CONFIG_MXS_LRADC) += mxs-lradc.o
Index: linux-4.9.87/drivers/mcuio/Makefile
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/Makefile
@@ -0,0 +1,10 @@
+# This comes from the zio Makefile
+
+LINUX ?= /lib/modules/$(shell uname -r)/build
+
+mcuio-y := core.o bus.o sysfs.o
+
+obj-$(CONFIG_MCUIO) += mcuio.o mcuio-hc-drv.o mcuio-hc-dev.o mcuio-soft-hc.o mcuio-soft-local-irq-ctrl-msg-dev.o
+obj-$(CONFIG_MCUIO_LDISC_HC) += mcuio-hc-ldisc.o
+obj-$(CONFIG_MCUIO_SHIELDS_MANUAL_PROBE) += mcuio-shields-manprobe.o
+obj-$(CONFIG_MCUIO_IRQ_TEST) += mcuio-irq-test.o
Index: linux-4.9.87/include/linux/mcuio-hc.h
===================================================================
--- /dev/null
+++ linux-4.9.87/include/linux/mcuio-hc.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * Header file for mcuio host controller
+ *
+ * GNU GPLv2 or later
+ */
+#ifndef __HOST_CONTROLLER_H__
+#define __HOST_CONTROLLER_H__
+
+#define MCUIO_HC_OUTBUF 0x8
+#define MCUIO_HC_INBUF 0x108
+/* How many 32bits words are in rx buffer */
+#define MCUIO_RX_CNT   0x208
+/* Irq register */
+#define MCUIO_IRQ      0x20c
+/* Irq status */
+#define MCUIO_IRQ_STAT  0x210
+#define RX_RDY         0x1
+/* Clear register */
+#define MCUIO_IRQ_CLR  0x214
+
+#define MCUIO_HC_MAX_REGISTER 0x214
+
+struct regmap;
+
+typedef struct regmap *(*setup_regmap)(struct device *, void *data);
+
+/*
+ * Platform data for host controller
+ *
+ * @setup_regmap: pointer to function setting up a regmap for controller
+ * @data: data to be passed on to setup_regmap.
+ */
+struct mcuio_hc_platform_data {
+	setup_regmap setup_regmap;
+	void *data;
+};
+
+/*
+ * mcuio_add_hc_device() : add host controller device
+ *
+ * @id: pointer to mcuio device's id
+ * @plat: pointer to platform data structure
+ * @release: pointer to custom release function
+ */
+struct device *mcuio_add_hc_device(struct mcuio_device_id *id,
+				   struct mcuio_hc_platform_data *plat,
+				   void (*release)(struct device *));
+
+/*
+ * mcuio_del_hc_device(): remove host controller device
+ *
+ * @dev: pointer to relevant struct device
+ */
+void mcuio_del_hc_device(struct device *);
+
+/*
+ * mcuio_hc_dev_default_release(): default release for hc devices
+ *
+ * @dev: pointer to corresponding device to be deleted
+ *
+ * If an hc is created with custom release function, such function can
+ * invoke mcuio_hc_dev_default_release() to perform some common release
+ * operations (freeing memory and releasing the mcuio bus number)
+ */
+void mcuio_hc_dev_default_release(struct device *dev);
+
+
+/*
+ * Set irq numbers for a given bus device (MCUIO_FUNCS_PER_DEV functions)
+ */
+int mcuio_hc_set_irqs(struct mcuio_device *hc, unsigned dev, int irqs[]);
+
+#endif /* __HOST_CONTROLLER_H__ */
Index: linux-4.9.87/include/linux/mcuio-proto.h
===================================================================
--- /dev/null
+++ linux-4.9.87/include/linux/mcuio-proto.h
@@ -0,0 +1,246 @@
+#ifndef __MCUIO_PROTO_H__
+#define __MCUIO_PROTO_H__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+
+#define mcuio_ntohq(a) le64_to_cpu(a)
+#define mcuio_htonq(a) cpu_to_le64(a)
+#define mcuio_ntohl(a) le32_to_cpu(a)
+#define mcuio_htonl(a) cpu_to_le32(a)
+#define mcuio_ntohs(a) le16_to_cpu(a)
+#define mcuio_htons(a) cpu_to_le16(a)
+
+#endif /* __KERNEL__ */
+
+
+#define mcuio_type_rdb			0
+#define mcuio_type_wrb			1
+#define mcuio_type_rdw			2
+#define mcuio_type_wrw			3
+#define mcuio_type_rddw			4
+#define mcuio_type_wrdw			5
+#define mcuio_type_rdq			6
+#define mcuio_type_wrq			7
+
+#define mcuio_error_bit			BIT(5)
+#define mcuio_reply_bit			BIT(6)
+#define mcuio_fill_data_bit		BIT(7)
+#define mcuio_actual_type_mask		0x07
+
+#define mask(b)				(BIT(b) - 1)
+
+#define mcuio_addr_offset_bits		12
+#define mcuio_addr_offset_shift		0
+#define mcuio_addr_offset_mask		mask(mcuio_addr_offset_bits)
+
+#define mcuio_addr_func_bits		5
+#define mcuio_addr_func_shift		mcuio_addr_offset_bits
+#define mcuio_addr_func_mask		mask(mcuio_addr_func_bits)
+#define MCUIO_FUNCS_PER_DEV		BIT(mcuio_addr_func_bits)
+
+#define mcuio_addr_dev_bits		4
+#define mcuio_addr_dev_shift		(mcuio_addr_func_bits + \
+					 mcuio_addr_offset_bits)
+#define mcuio_addr_dev_mask		mask(mcuio_addr_dev_bits)
+#define MCUIO_DEVS_PER_BUS		BIT(mcuio_addr_dev_bits)
+
+#define mcuio_addr_bus_bits		3
+#define mcuio_addr_bus_shift		(mcuio_addr_func_bits + \
+					 mcuio_addr_offset_bits + \
+					 mcuio_addr_dev_bits)
+#define mcuio_addr_bus_mask		mask(mcuio_addr_bus_bits)
+
+#define mcuio_addr_type_bits		8
+#define mcuio_addr_type_shift		(mcuio_addr_func_bits + \
+					 mcuio_addr_offset_bits + \
+					 mcuio_addr_dev_bits + \
+					 mcuio_addr_bus_bits)
+#define mcuio_addr_type_mask		mask(mcuio_addr_type_bits)
+
+struct mcuio_packet {
+	uint32_t addr;
+	uint32_t data[2];
+	uint16_t crc;
+	uint16_t dummy;
+} __attribute__((packed));
+
+static inline unsigned mcuio_packet_type(struct mcuio_packet *p)
+{
+	return mcuio_ntohl(p->addr) >> mcuio_addr_type_shift;
+}
+
+static inline void mcuio_set_packet_type(struct mcuio_packet *p, uint32_t t)
+{
+	p->addr &= (mcuio_addr_type_mask << mcuio_addr_type_shift);
+	p->addr |= mcuio_htonl(t) << mcuio_addr_type_shift;
+}
+
+static inline unsigned mcuio_data_size(unsigned t)
+{
+	if (t & mcuio_fill_data_bit)
+		return sizeof(uint64_t);
+	return (1 << ((t & ~1) >> 1));
+}
+
+static inline unsigned mcuio_packet_data_size(struct mcuio_packet *p)
+{
+	return mcuio_data_size(mcuio_packet_type(p));
+}
+
+static inline int mcuio_type_is_read(unsigned t)
+{
+	return !(t & 0x1);
+}
+
+static inline int mcuio_packet_is_read(struct mcuio_packet *p)
+{
+	return mcuio_type_is_read(mcuio_packet_type(p));
+}
+
+static inline int mcuio_packet_is_write(struct mcuio_packet *p)
+{
+	return !mcuio_type_is_read(mcuio_packet_type(p));
+}
+
+static inline int mcuio_packet_is_reply(struct mcuio_packet *p)
+{
+	return (mcuio_packet_type(p) & mcuio_reply_bit);
+}
+
+static inline int mcuio_packet_is_fill_data(struct mcuio_packet *p)
+{
+	return (mcuio_packet_type(p) & mcuio_fill_data_bit);
+}
+
+static inline unsigned mcuio_packet_offset(struct mcuio_packet *p)
+{
+	return (mcuio_ntohl(p->addr) >> mcuio_addr_offset_shift) &
+		mcuio_addr_offset_mask;
+}
+
+static inline unsigned mcuio_packet_func(struct mcuio_packet *p)
+{
+	return (mcuio_ntohl(p->addr) >> mcuio_addr_func_shift) &
+		mcuio_addr_func_mask;
+}
+
+static inline unsigned mcuio_packet_dev(struct mcuio_packet *p)
+{
+	return (mcuio_ntohl(p->addr) >> mcuio_addr_dev_shift) &
+		mcuio_addr_dev_mask;
+}
+
+static inline unsigned mcuio_packet_bus(struct mcuio_packet *p)
+{
+	return (mcuio_ntohl(p->addr) >> mcuio_addr_bus_shift) &
+		mcuio_addr_bus_mask;
+}
+
+static inline void mcuio_packet_set_addr(struct mcuio_packet *p,
+					 unsigned bus, unsigned dev,
+					 unsigned func, unsigned offset,
+					 unsigned type, int fill)
+{
+	p->addr = mcuio_htonl(((offset & mcuio_addr_offset_mask) <<
+			       mcuio_addr_offset_shift) |
+			      ((func & mcuio_addr_func_mask) <<
+			       mcuio_addr_func_shift) |
+			      ((dev & mcuio_addr_dev_mask) <<
+			       mcuio_addr_dev_shift) |
+			      ((bus & mcuio_addr_bus_mask) <<
+			       mcuio_addr_bus_shift) |
+			      (((type & mcuio_addr_type_mask) |
+				(fill ? mcuio_fill_data_bit : 0)) <<
+			       mcuio_addr_type_shift));
+}
+
+static inline int mcuio_packet_is_reply_to(struct mcuio_packet *p,
+					   struct mcuio_packet *request)
+{
+	unsigned t = mcuio_packet_type(p);
+	unsigned rt = mcuio_packet_type(request);
+	unsigned o = mcuio_packet_offset(p);
+	unsigned ro = mcuio_packet_offset(request);
+	unsigned f = mcuio_packet_func(p);
+	unsigned rf = mcuio_packet_func(request);
+	unsigned d = mcuio_packet_dev(p);
+	unsigned rd = mcuio_packet_dev(request);
+	unsigned b = mcuio_packet_bus(p);
+	unsigned rb = mcuio_packet_bus(request);
+
+	pr_debug("type = 0x%02x, request type = 0x%02x\n", t, rt);
+	return (t & mcuio_actual_type_mask) == rt && o == ro && f == rf &&
+		d == rd && b == rb;
+}
+
+
+static inline void mcuio_packet_set_reply(struct mcuio_packet *p)
+{
+	mcuio_set_packet_type(p, mcuio_packet_type(p) | mcuio_reply_bit);
+}
+
+static inline int mcuio_packet_is_error(struct mcuio_packet *p)
+{
+	return mcuio_packet_type(p) & mcuio_error_bit;
+}
+
+static inline void mcuio_packet_set_error(struct mcuio_packet *p)
+{
+	mcuio_set_packet_type(p, mcuio_packet_type(p) | mcuio_error_bit);
+}
+
+static inline void mcuio_packet_set_fill_data(struct mcuio_packet *p)
+{
+	mcuio_set_packet_type(p, mcuio_packet_type(p) | mcuio_fill_data_bit);
+}
+
+static inline const char *mcuio_packet_type_to_str(int t)
+{
+	switch(t & mcuio_actual_type_mask) {
+	case mcuio_type_rdb:
+		return "rdb";
+	case mcuio_type_wrb:
+		return "wrb";
+	case mcuio_type_rdw:
+		return "rdw";
+	case mcuio_type_wrw:
+		return "wrw";
+	case mcuio_type_rddw:
+		return "rddw";
+	case mcuio_type_wrdw:
+		return "wrdw";
+	case mcuio_type_rdq:
+		return "rdq";
+	case mcuio_type_wrq:
+		return "wrq";
+	}
+	return "unknown";
+}
+
+struct mcuio_func_descriptor {
+	uint32_t device_vendor;
+	uint32_t rev_class;
+} __attribute__((packed));
+
+static inline uint16_t mcuio_get_vendor(struct mcuio_func_descriptor *d)
+{
+	return mcuio_ntohs(mcuio_ntohl(d->device_vendor) & 0xffff);
+}
+
+static inline uint16_t mcuio_get_device(struct mcuio_func_descriptor *d)
+{
+	return mcuio_ntohs(mcuio_ntohl(d->device_vendor) >> 16);
+}
+
+static inline uint32_t mcuio_get_class(struct mcuio_func_descriptor *d)
+{
+	return mcuio_ntohl(d->rev_class) >> 8;
+}
+
+static inline uint32_t mcuio_get_rev(struct mcuio_func_descriptor *d)
+{
+	return mcuio_ntohl(d->rev_class) & ((1 << 8) - 1);
+}
+
+#endif /* __MCUIO_PROTO_H__ */
Index: linux-4.9.87/include/linux/mcuio-soft-hc.h
===================================================================
--- /dev/null
+++ linux-4.9.87/include/linux/mcuio-soft-hc.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2011 Dog Hunter SA
+ * Author: Davide Ciminaghi <ciminaghi@gnudd.com>
+ *
+ * GNU GPLv2 or later
+ */
+
+/* mcuio generic soft host controller functions and data structs, header file */
+
+#ifndef __MCUIO_SOFT_HOST_CONTROLLER_H__
+#define __MCUIO_SOFT_HOST_CONTROLLER_H__
+
+#include <linux/circ_buf.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/irq.h>
+#include <linux/mcuio-proto.h>
+
+struct mcuio_soft_hc;
+
+struct mcuio_soft_hc_ops {
+	int (*write)(struct mcuio_soft_hc *, const u8 *ptr, unsigned int len);
+};
+
+/*
+ * A soft mcuio host controller
+ *
+ * @id: pointer to corresponding mcuio device's id.
+ * @irqstat: current irq status register
+ * @irqno: number of [virtual] irq
+ * @irq_enabled: irq enabled when !0
+ * @rx_circ_buf: circular buffer structure for rx data management
+ * @rx_buf: actual rx data buffer
+ * @ops: pointer to hc operations
+ * @chip: related irqchip
+ * @irq_kworker:
+ * @irq_kworker_task:
+ * @do_irq:
+ * @hc: pointer to host controller (mcuio device)
+ * @irq_controllers: array of pointers to soft irq controllers
+ * @priv: client driver private data
+ */
+struct mcuio_soft_hc {
+	struct mcuio_device_id *id;
+	u32 irqstat;
+	int irqno;
+	int irq_enabled;
+	struct circ_buf rx_circ_buf;
+	char rx_buf[256];
+	const struct mcuio_soft_hc_ops *ops;
+	struct irq_chip chip;
+	struct kthread_worker irq_kworker;
+	struct task_struct *irq_kworker_task;
+	struct kthread_work do_irq;
+	struct mcuio_device *hc;
+	struct mcuio_device *irq_controllers[MCUIO_DEVS_PER_BUS];
+	void *priv;
+};
+
+/* Instantiate a soft host controller */
+/*
+ * mcuio_add_soft_hc
+ *
+ * @id: pointer to corresponding mcuio device's id.
+ * @ops: pointer to operations structure
+ * @priv: pointer to private data
+ *
+ * Returns pointer to corresponding device
+ */
+struct device *mcuio_add_soft_hc(struct mcuio_device_id *id,
+				 const struct mcuio_soft_hc_ops *ops,
+				 void *priv);
+
+/* Push chars from soft host controller client driver */
+/*
+ * mcuio_soft_hc_push_chars()
+ *
+ * @shc: pointer to soft host controller data structure
+ * @buf: pointer to input buffer
+ * @len: length of buffer
+ */
+int mcuio_soft_hc_push_chars(struct mcuio_soft_hc *shc, const u8 *buf, int len);
+
+
+#endif /* __MCUIO_SOFT_HOST_CONTROLLER_H__ */
Index: linux-4.9.87/include/linux/mcuio.h
===================================================================
--- /dev/null
+++ linux-4.9.87/include/linux/mcuio.h
@@ -0,0 +1,195 @@
+#ifndef __MCUIO_H__
+#define __MCUIO_H__
+
+#ifdef __KERNEL__
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+struct mcuio_packet;
+
+/*
+ * Id of an mcuio device.
+ */
+struct mcuio_device_id {
+	unsigned int device;
+	unsigned int vendor;
+	unsigned int class;
+	unsigned int class_mask;
+};
+
+/*
+ * An mcuio device.
+ * @id: device id, as defined above
+ * @bus: bus number
+ * @device: device number (0 for host controllers)
+ * @fn: function number (0 for host controllers)
+ * @dev: the relevant device
+ * @irq: irq number for device
+ */
+struct mcuio_device {
+	struct mcuio_device_id id;
+	unsigned bus, device, fn;
+	struct device dev;
+	int irq;
+};
+
+#define to_mcuio_dev(_dev) container_of(_dev, struct mcuio_device, dev)
+
+/*
+ * mcuio_driver -- an mcuio driver struc
+ */
+struct mcuio_driver {
+	const struct mcuio_device_id	*id_table;
+	int (*probe)(struct mcuio_device *dev);
+	int (*remove)(struct mcuio_device *dev);
+	int (*input_ready)(struct mcuio_device *dev);
+	struct device_driver		driver;
+};
+
+#define to_mcuio_drv(_drv) container_of(_drv, struct mcuio_driver, driver)
+
+/*
+ * The parent of all mcuio controllers on this machine
+ */
+extern struct device mcuio_bus;
+
+int mcuio_driver_register(struct mcuio_driver *drv, struct module *owner);
+void mcuio_driver_unregister(struct mcuio_driver *drv);
+int mcuio_device_register(struct mcuio_device *dev,
+			  struct device_type *type,
+			  struct device *parents);
+void mcuio_device_unregister(struct mcuio_device *dev);
+
+struct mcuio_request;
+
+typedef void (*request_cb)(struct mcuio_request *);
+
+/*
+ * mcuio request flags
+ */
+/*
+ * fill: if this is !0 the resulting request packet shall have its fill data
+ *       flag set
+ */
+#define MCUIO_REQUEST_FILL BIT(0)
+/*
+ * incoming: if this is !0 the request is incoming (outgoing otherwise)
+ */
+#define MCUIO_REQUEST_INCOMING BIT(1)
+
+/*
+ * This represents an mcuio request
+ * @hc: pointer to host controller mcuio device
+ * @dev: destination device
+ * @func: destination function
+ * @offset: offset within function address space
+ * @offset_mask: this mask is applied to incoming packets' offsets when
+ *		 looking for matching pending requests
+ * @type: request type
+ * @cb: pointer to callback function
+ * @cb_data: callback data.
+ * @status: status of request (0 completed OK, -EXXXX errors)
+ * @data: request data
+ * @list: used for enqueueing requests
+ * @to_work: delayed_work struct for request timeout management
+ * @priv: private data. FIX THIS
+ * @flags: request flags (MCUIO_REQUEST_XXX)
+ * @release: pointer to memory release function
+ */
+struct mcuio_request {
+	struct mcuio_device *hc;
+	unsigned dev;
+	unsigned func;
+	unsigned offset;
+	unsigned offset_mask;
+	unsigned type;
+	request_cb cb;
+	void *cb_data;
+	int status;
+	uint32_t data[2];
+	struct list_head list;
+	struct delayed_work to_work;
+	void *priv;
+	unsigned int flags;
+	void (*release)(struct mcuio_request *);
+};
+
+static inline int mcuio_request_is_fill(struct mcuio_request *r)
+{
+	return r->flags & MCUIO_REQUEST_FILL;
+}
+
+static inline void mcuio_request_set_fill(struct mcuio_request *r, int f)
+{
+	r->flags &= ~MCUIO_REQUEST_FILL;
+	if (f)
+		r->flags |= MCUIO_REQUEST_FILL;
+}
+
+static inline int mcuio_request_is_incoming(struct mcuio_request *r)
+{
+	return r->flags & MCUIO_REQUEST_INCOMING;
+}
+
+static inline void mcuio_request_set_incoming(struct mcuio_request *r, int f)
+{
+	r->flags &= ~MCUIO_REQUEST_INCOMING;
+	if (f)
+		r->flags |= MCUIO_REQUEST_INCOMING;
+}
+
+/*
+ * Submit a request, block until request done
+ *
+ * @r: pointer to request
+ */
+int mcuio_submit_request(struct mcuio_request *r);
+
+/*
+ * Setup a callback for an incoming request
+ *
+ * @r: pointer to corresponding request
+ */
+int mcuio_setup_cb(struct mcuio_request *r);
+
+/*
+ * Cancel a callback for an incoming request
+ *
+ * @r: pointer to corresponding request
+ */
+int mcuio_cancel_cb(struct mcuio_request *r);
+
+/*
+ * Fill a non-dynamically allocated mcuio request
+ */
+void mcuio_init_request(struct mcuio_request *r,
+			struct mcuio_device *mdev,
+			unsigned dev, unsigned func,
+			unsigned type,
+			int fill,
+			unsigned offset,
+			unsigned offset_mask);
+
+/*
+ * Dynamically allocate an mcuio request and initialize it
+ */
+struct mcuio_request *mcuio_make_request(struct mcuio_device *mdev,
+					 unsigned dev, unsigned func,
+					 unsigned type,
+					 int fill,
+					 unsigned offset,
+					 unsigned offset_mask);
+
+/*
+ * Free an mcuio request
+ */
+static inline void mcuio_free_request(struct mcuio_request *r)
+{
+	if (r->release)
+		r->release(r);
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* __MCUIO_H__ */
Index: linux-4.9.87/include/linux/mcuio_ids.h
===================================================================
--- /dev/null
+++ linux-4.9.87/include/linux/mcuio_ids.h
@@ -0,0 +1,46 @@
+#ifndef __MCUIO_IDS_H__
+#define __MCUIO_IDS_H__
+
+/* Various class definitions */
+
+#define MCUIO_CLASS_UNDEFINED	    0x0000
+/* Hardware implementation of host controller */
+#define MCUIO_CLASS_HOST_CONTROLLER 0x0001
+/* Software implementation of host controller (line discipline) */
+#define MCUIO_CLASS_SOFT_HOST_CONTROLLER 0x0011
+#define MCUIO_CLASS_GPIO	    0x0002
+#define MCUIO_CLASS_ADC		    0x0003
+#define MCUIO_CLASS_DAC		    0x0004
+#define MCUIO_CLASS_PWM		    0x0005
+#define MCUIO_CLASS_GRAPHIC_DISPLAY 0x0006
+#define MCUIO_CLASS_TEXT_DISPLAY    0x0007
+#define MCUIO_CLASS_I2C_CONTROLLER  0x0008
+#define MCUIO_CLASS_SPI_CONTROLLER  0x0009
+/* Send irqs from MCU via communication protocol */
+#define MCUIO_CLASS_IRQ_CONTROLLER_PROTO  0x000a
+/* Send irqs from MCU via gpio */
+#define MCUIO_CLASS_IRQ_CONTROLLER_WIRE   0x000b
+/* Add-on shield */
+#define MCUIO_CLASS_SHIELD	    0x000c
+/* Local message based irq controller */
+#define MCUIO_CLASS_SOFT_LOCAL_IRQ_CONTROLLER_PROTO 0x000d
+
+
+/* Invalid device id (used for id table termination */
+#define MCUIO_NO_DEVICE		    0x0000
+
+
+/* Vendors */
+#define MCUIO_VENDOR_DOGHUNTER	    0x0001
+
+
+/* Specific devices */
+#define MCUIO_DEVICE_JOYSTICK_SHIELD 0x0001
+#define MCUIO_DEVICE_LUCKY_SHIELD    0x0002
+#define MCUIO_DEVICE_DIGITALIO_SHIELD 0x0003
+#define MCUIO_DEVICE_SOFT_HC	     0x0004
+#define MCUIO_DEVICE_GENERIC_HC	     0x0005
+#define MCUIO_DEVICE_DOGOLED_SHIELD	0x0006
+#define MCUIO_DEVICE_LOCAL_IRQC_MSG  0x0007
+
+#endif /* __MCUIO_IDS_H__ */
Index: linux-4.9.87/drivers/mcuio/mcuio-shields-manprobe.c
===================================================================
--- /dev/null
+++ linux-4.9.87/drivers/mcuio/mcuio-shields-manprobe.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2014 Dog Hunter SA
+ * Author: Aurelio Colosimo <aurelio@aureliocolosimo.it>
+ *
+ * GNU GPLv2 or later
+ */
+
+#define DEBUG
+
+/* mcuio module for manual probe of shields */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+
+#include "mcuio-internal.h"
+
+struct shld_probe_info {
+	char *name;
+	unsigned int func_nr;
+	struct mcuio_device *mdev;
+	struct mcuio_device_id mdev_id;
+	int probed;
+};
+
+#define DH_SHLD(n, did, fnr) { \
+	.name = n, \
+	.func_nr = fnr, \
+	.mdev_id = { \
+		.device = did, \
+		.vendor = MCUIO_VENDOR_DOGHUNTER, \
+		.class = MCUIO_CLASS_SHIELD, \
+		.class_mask = 0xffffffff,\
+	}\
+}
+
+struct shld_probe_info shld_list[] = {
+	DH_SHLD("lucky", MCUIO_DEVICE_LUCKY_SHIELD, 31),
+	DH_SHLD("digitalio", MCUIO_DEVICE_DIGITALIO_SHIELD, 30),
+	DH_SHLD("dogoled", MCUIO_DEVICE_DOGOLED_SHIELD, 29),
+	{.name = NULL},
+};
+
+int shld_register(struct shld_probe_info *info)
+{
+	int ret = -ENOMEM;
+	struct mcuio_device *mdev;
+	struct mcuio_device *hc;
+
+	/* FIXME shld_register always acts on bus=0
+	 * (only one bus is supported at present) */
+	hc = mcuio_bus_find_hc(0);
+	if (IS_ERR(hc))
+		return -ENODEV;
+
+	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
+	if (!mdev)
+		return -ENOMEM;
+
+	mdev->id = info->mdev_id;
+	mdev->fn = info->func_nr;
+
+	pr_debug("mcuio shield: device = 0x%04x, vendor = 0x%04x, "
+		 "class = 0x%04x\n", mdev->id.device,
+		 mdev->id.vendor, mdev->id.class);
+
+	if (mcuio_device_register(mdev, NULL, &hc->dev) < 0) {
+		dev_err(&hc->dev,
+			"error registering device %u:%u.%u\n",
+			hc->bus, mdev->device, mdev->fn);
+		goto err0;
+	}
+
+	info->mdev = mdev;
+
+	return 0;
+
+err0:
+	kfree(mdev);
+	return ret;
+}
+
+void shld_unregister(struct shld_probe_info *info)
+{
+	if (!IS_ERR(mcuio_bus_find_hc(0)))
+		mcuio_device_unregister(info->mdev);
+	info->mdev = NULL;
+}
+
+
+static int shld_probe(const char *shld_name)
+{
+	struct shld_probe_info *i;
+	for (i = shld_list; i->name; i++) {
+		if (sysfs_streq(shld_name, i->name) && !i->probed &&
+			!shld_register(i)) {
+				i->probed = 1;
+				return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static void shld_remove(const char *shld_name)
+{
+	struct shld_probe_info *i;
+	for (i = shld_list; i->name; i++)
+		if (sysfs_streq(shld_name, i->name) && i->probed) {
+			shld_unregister(i);
+			i->probed = 0;
+		}
+}
+
+static ssize_t show_shld_list(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct shld_probe_info *i;
+	buf[0] = '\0';
+	for (i = shld_list; i->name; i++) {
+		strcat(buf, i->name);
+		strcat(buf, "\t");
+	}
+	strcat(buf, "\n");
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(shield_list, S_IRUSR, show_shld_list, NULL);
+
+static ssize_t store_shld_register(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int ret;
+	ret = shld_probe(buf);
+	if (ret)
+		dev_err(dev, "%s probe failed ret=%d\n", buf, ret);
+	return count;
+}
+
+static DEVICE_ATTR(shield_register, S_IWUSR, NULL, store_shld_register);
+
+static ssize_t store_shld_unregister(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	shld_remove(buf);
+	return count;
+}
+
+static DEVICE_ATTR(shield_unregister, S_IWUSR, NULL, store_shld_unregister);
+
+static int __init shld_core_init(void)
+{
+	device_create_file(&mcuio_bus, &dev_attr_shield_list);
+	device_create_file(&mcuio_bus, &dev_attr_shield_register);
+	device_create_file(&mcuio_bus, &dev_attr_shield_unregister);
+	return 0;
+}
+
+static void __exit shld_core_exit(void)
+{
+	device_remove_file(&mcuio_bus, &dev_attr_shield_list);
+	device_remove_file(&mcuio_bus, &dev_attr_shield_register);
+	device_remove_file(&mcuio_bus, &dev_attr_shield_unregister);
+}
+
+late_initcall(shld_core_init);
+module_exit(shld_core_exit);
+
+MODULE_AUTHOR("Aurelio Colosimo");
+MODULE_DESCRIPTION("driver for MCUIO shields manual probe");
+MODULE_LICENSE("GPL v2");
